// Classic RPG System
// A comprehensive RPG with traditional classes, skill trees, and boss battles

// Character information with class and level progression
component Character {
    name: string
    class: string
    level: integer
    experience: integer
    experienceToLevel: integer
}

// Health component
component Health {
    current: integer
    max: integer
}

// Mana component for spell casting
component Mana {
    current: integer
    max: integer
}

// Character stats
component Stats {
    strength: integer
    dexterity: integer
    intelligence: integer
    constitution: integer
    wisdom: integer
}

// Combat stats
component Combat {
    damage: integer
    defense: integer
    attackSpeed: float
    critChance: float
    critMultiplier: float
}

// Current attack target
component Target {
    entity: id?
}

// Team affiliation
component Team {
    id: string
    isPlayer: boolean
}

// Enemy information
component Enemy {
    tier: integer
    isBoss: boolean
    expReward: integer
    wave: integer
    name: string
}

// Marks an entity as an enemy template (not a spawned enemy)
component EnemyTemplate {
    isTemplate: boolean
}

// Marks an entity as the final boss
component FinalBoss {
    isFinalBoss: boolean
}

// Component that marks when Lord Vexar has been defeated
// This component is created on the GameState entity when the final boss is defeated
// Used for testing and verification that the game ended properly
component LordVexarDefeated {
    defeatedAt: float
    defeatedByHeroCount: integer
}

// Holds references to all enemy templates / entries in the game
// Holds references to all enemy templates / entries in the game
component EnemyCompendium {
    entries: list<id>
}

// Character skills
component Skills {
    skill1: string
    skill2: string
    skill3: string
    skill4: string
    skillPoints: integer
}

// Active buffs
component Buffs {
    damageBonus: integer
    defenseBonus: integer
    hasteBonus: float
    shieldAmount: integer
    regenAmount: integer
}

// Game state tracking
component GameState {
    currentWave: integer
    enemiesDefeated: integer
    playerDeaths: integer
    bossDefeated: boolean
    gameOver: boolean
    victory: boolean
    retargetingActive: boolean
    currentTier: integer
    waveInTier: integer
    bossSpawned: boolean
}

// Run tracking for leaderboard
component RunStats {
    simulationTime: float
    retreatCount: integer
    retreatPenalty: float
    deathPenalty: float
    totalTime: float
    canFlee: boolean
    lastFleeTime: float
}

// Flee constants (defined as component for easy tuning)
component FleeConfig {
    retreatTimePenalty: float      // 10 seconds
    deathTimePenaltyMultiplier: float  // 5x = 50 seconds
    fleeCooldown: float            // 5 seconds between flees
}

// Skill cooldown tracking
component SkillCooldown {
    skill1Cooldown: float
    skill2Cooldown: float
    skill3Cooldown: float
    skill4Cooldown: float
}

// Choice context for player decisions
component ChoiceContext {
    pendingChoice: string
    options: string
    chosen: string
}

// Hero information for party selection UI (used by BDL)
component HeroInfo {
    id: string
    description: string
    difficulty: string
    role: string
    playstyle: string
}

// Marks an entity as a hero template (not a spawned hero)
component HeroTemplate {
    isTemplate: boolean
}

// Spawn configuration (used by BDL)
component SpawnConfig {
    bossEveryKills: integer
    tierProgressionKills: integer
    maxTier: integer
    wavesPerTier: integer
    healthScaleRate: integer
    damageScaleRate: integer
    initialEnemyCount: integer
}

// Scenario information for scenario selection UI (used by BDL)
component ScenarioInfo {
    id: string
    name: string
    description: string
    difficulty: string
    respawnTime: string
    deathPenalty: string
    enemiesPerWave: string
    bossFrequency: string
}

// Helper function to calculate damage
fn calculate_damage(base: float, bonus: float): float {
    return base + bonus
}

// Helper function to calculate experience for level
fn calculate_exp_for_level(level: float): float {
    return 100 * level
}

// ============================================================================
// GAME INITIALIZATION RULES
// ============================================================================

// Rule 1: Start hero attacks when game begins
rule initialize_hero_attacks on GameStart(gs: id) {
let heroes: list = entities having Team
    for hero in heroes {
        if hero.Team.isPlayer && hero.Health.current > 0 {
            // Stagger attacks by 0.1s per hero to avoid perfect synchronization
            schedule [delay: 0.1] DoAttack {
                source: hero
            }
        }
    }
}

// Rule 2: Start retargeting system when game begins
rule start_retargeting_system on GameStart(gs: id) {
let gameStates: list = entities having GameState
    for state in gameStates {
        if state.GameState.retargetingActive == false {
            state.GameState.retargetingActive = true
            // Schedule first retargeting check in 2 seconds
            schedule [delay: 2.0] CheckAllTargets {
            }
        }
    }
}

// Rule 3: Spawn initial enemies when game begins
rule spawn_initial_enemies on GameStart(gs: id) {
let spawners: list = entities having SpawnConfig
    for spawner in spawners {
let count: id = spawner.SpawnConfig.initialEnemyCount
        // Initialize tiered wave tracking
        spawner.GameState.currentTier = 1
        spawner.GameState.waveInTier = 1
        spawner.GameState.currentWave = 1
        spawner.GameState.bossSpawned = false

        // Spawn initial wave enemies (spread by small delays)
let indices: list = [0, 1, 2, 3, 4]
        for i in indices {
            schedule [delay: 0.5 * (i + 1)] SpawnEnemy {
                tier: 1
            }
        }

        // Notify that the first wave spawned
        schedule [delay: 3.0] EnemySpawned {
            wave: 1
        }
    }
}

// Handle a wave starting: spawn its enemies and schedule the next wave
rule handle_enemy_spawned on EnemySpawned(es: id) {
let spawners: list = entities having GameState
    for spawner in spawners {
        // Determine current tier and wave index
let tier: id = spawner.GameState.currentTier
let waveIndex: id = spawner.GameState.waveInTier
let count: id = spawner.SpawnConfig.initialEnemyCount

        // Spawn enemies for this wave
let indices: list = [0, 1, 2, 3, 4]
        for i in indices {
            schedule [delay: 0.5 * (i + 1)] SpawnEnemy {
                tier: tier
            }
        }

        // If this is the final tier, spawn the named final boss once
        if tier == spawner.SpawnConfig.maxTier {
            if spawner.GameState.bossSpawned == false {
                schedule [delay: 1.0] SpawnLordVexar {
                }
                spawner.GameState.bossSpawned = true
            }
        } else {
            // Not final tier - schedule the next wave
            let nextWaveIndex: integer = waveIndex + 1
            if nextWaveIndex > spawner.SpawnConfig.wavesPerTier {
                spawner.GameState.currentTier = tier + 1
                spawner.GameState.waveInTier = 1
            } else {
                spawner.GameState.waveInTier = nextWaveIndex
            }
            spawner.GameState.currentWave += 1

            // Schedule next EnemySpawned event for the next wave
            schedule [delay: 2.0] EnemySpawned {
                wave: spawner.GameState.currentWave
            }
        }
    }
}

// ============================================================================
// ENEMY SPAWNING RULES
// ============================================================================

// Spawn a single enemy by cloning a template
rule spawn_enemy_from_template on SpawnEnemy(se: id) {
let spawners: list = entities having SpawnConfig
    if len(spawners) > 0 {
        // Find enemy templates matching the requested tier
let templates: list = entities having EnemyTemplate

        // Try to find a template matching the requested tier (fallback to first)
let templateId: id = templates[0]
        for t in templates {
            if t.EnemyTemplate.isTemplate {
                if t.Enemy.tier == se.tier {
                    templateId = t
                }
            }
        }

        // Clone the selected template and mark it as not a template
let newEnemy: id = clone templateId {
            EnemyTemplate {
                isTemplate: false
            }
        }
        
        // Target will be assigned by the retargeting system
        newEnemy.Target.entity = null
        
        // Schedule the enemy's first attack
        schedule [delay: 0.1] DoAttack {
            source: newEnemy
        }
    }
}

// Spawn the final boss (Dragon Lord Vexar) once
rule spawn_lord_vexar on SpawnLordVexar(slv: id) {
let spawners: list = entities having SpawnConfig
    if len(spawners) > 0 {
        // Find the final boss template using FinalBoss component
let templates: list = entities having FinalBoss
let bossTemplate: id = templates[0]
        
        // Clone the boss template
let newBoss: id = clone bossTemplate {
            EnemyTemplate {
                isTemplate: false
            }
        }

        // Target will be assigned by the retargeting system
        newBoss.Target.entity = null
        schedule [delay: 0.5] DoAttack {
            source: newBoss
        }
    }
}

// ============================================================================
// COMBAT RULES
// ============================================================================

// Main attack rule: apply damage and schedule next attack
rule attack_rule on DoAttack(da: id) {
let attacker: id = da.source
    if attacker.Target.entity != null && attacker.Health.current > 0 {
let target: id = attacker.Target.entity
let damage: id = attacker.Combat.damage + attacker.Buffs.damageBonus
        
        // Apply damage to target
        target.Health.current -= damage
        
        // Emit after attack event
        schedule AfterAttack {
            attacker: attacker
            target: target
        }
        
        // Schedule next attack
let attackSpeedTotal: id = attacker.Combat.attackSpeed + attacker.Buffs.hasteBonus
        if attackSpeedTotal <= 0 {
            attackSpeedTotal = 0.1
        }
let delay: float = 1 / attackSpeedTotal
        schedule [delay: delay] DoAttack {
            source: attacker
        }
    }
}

// Death check: emit Death event when health drops to zero
rule death_check on AfterAttack(aa: id) {
let target: id = aa.target
    if target.Health.current <= 0 {
        schedule Death {
            target: target
        }
    }
}

// Enemy death handler
rule enemy_death_handler on Death(d: id) {
let target: id = d.target
let enemies: list = entities having Enemy
    for enemy in enemies {
        if enemy == target && enemy.Health.current <= 0 {
            schedule EnemyDefeated {
                enemy: enemy
                expReward: enemy.Enemy.expReward
                isBoss: enemy.Enemy.isBoss
            }
        }
    }
}

// Player death handler
rule player_death_handler on Death(d: id) {
let target: id = d.target
let players: list = entities having Team
    for player in players {
        if player == target && player.Team.isPlayer && player.Health.current <= 0 {
            schedule PlayerDefeated {
                player: player
            }
        }
    }
}

// When a player is defeated, schedule a respawn after 120 seconds
rule respawn_on_player_defeated on PlayerDefeated(pd: id) {
    // Don't respawn players if Lord Vexar has been defeated (game is over)
let gameStates: list = entities having GameState
let shouldRespawn: boolean = true
    if len(gameStates) > 0 {
let gameState: id = gameStates[0]
        if gameState.GameState.gameOver {
            if gameState.GameState.victory {
                shouldRespawn = false
            }
        }
    }
    
    // Schedule respawn for the dead player after 120s
    if shouldRespawn {
        schedule [delay: 120.0] RespawnPlayer {
            player: pd.player
        }
    }
}

// Restore player state when the RespawnPlayer event fires
rule respawn_player on RespawnPlayer(rp: id) {
let p: id = rp.player
    // Restore health and mana
    p.Health.current = p.Health.max
    p.Mana.current = p.Mana.max
    // Clear temporary buffs that should not persist through death
    p.Buffs.shieldAmount = 0
    p.Buffs.regenAmount = 0
    p.Buffs.damageBonus = 0
    p.Buffs.defenseBonus = 0
    p.Buffs.hasteBonus = 0.0
    // Allow fleeing again and reset any run-state flags as appropriate
    p.RunStats.canFlee = true
}

// Grant experience to players when enemy defeated
rule grant_experience on EnemyDefeated(ed: id) {
let gameStates: list = entities having GameState
    if len(gameStates) > 0 {
        // Find all player entities and grant them XP
let players: list = entities having Team
        for player in players {
            if player.Team.isPlayer {
                player.Character.experience += 50
                schedule CheckLevelUp {
                    source: player
                }
            }
        }
    }
}

// Level up check
rule level_up_check on CheckLevelUp(clu: id) {
let character: id = clu.source
    if character.Character.experience >= character.Character.experienceToLevel {
        character.Character.level += 1
        character.Character.experience -= character.Character.experienceToLevel
        character.Character.experienceToLevel *= 1.5
        character.Skills.skillPoints += 1
        
        schedule LevelUp {
            source: character
        }
        
        schedule SkillChoice {
            source: character
        }
    }
}

// Level up stat increases
rule level_up_stats on LevelUp(lu: id) {
let character: id = lu.source
    character.Health.max += 10
    character.Health.current += 10
    character.Combat.damage += 2
    character.Combat.defense += 1
}

// Track enemy defeats and check victory
rule boss_defeated_victory on EnemyDefeated(ed: id) {
let gameStates: list = entities having GameState
    for gameState in gameStates {
        gameState.GameState.enemiesDefeated += 1
        // If this was the named final boss, finish the run with victory.
        if ed.isBoss {
let defeated: id = ed.enemy
            if defeated.Enemy.name == "Lord Vexar" {
                gameState.GameState.bossDefeated = true
                gameState.GameState.victory = true
                gameState.GameState.gameOver = true
                
                // Add LordVexarDefeated component to track this specific victory
                gameState.LordVexarDefeated.defeatedAt = gameState.RunStats.simulationTime
                gameState.LordVexarDefeated.defeatedByHeroCount = 4
                
                // Emit dedicated LordVexarDefeated event
                schedule LordVexarDefeated {
                    boss: defeated
                }
                
                schedule GameOver {
                    victory: true
                }
            }
        }
    }
}

// Spawn a replacement enemy when one is defeated
rule spawn_replacement_enemy on EnemyDefeated(ed: id) {
let gameStates: list = entities having GameState
    for gameState in gameStates {
        // Don't spawn new enemies if Lord Vexar has been defeated
let vexarDefeated: list = entities having LordVexarDefeated
        if len(vexarDefeated) == 0 {
            if gameState.GameState.enemiesDefeated < 1000 {
                if gameState.GameState.gameOver == false {
                    if gameState.GameState.bossSpawned == false {
                        // Spawn enemy from current tier to maintain combat
let currentTier: id = gameState.GameState.currentTier
                        schedule [delay: 0.1] SpawnEnemy {
                            tier: currentTier
                        }
                    }
                }
            }
        }
    }
}

// Power strike skill
rule use_skill_power_strike on UseSkill(us: id) {
let character: id = us.source
    if character.Skills.skill1 == "power_strike" {
        character.Buffs.damageBonus += 5
    }
}

// Fireball skill
rule use_skill_fireball on UseSkill(us: id) {
let character: id = us.source
    if character.Skills.skill1 == "fireball" && character.Mana.current >= 20 {
        character.Mana.current -= 20
        character.Buffs.damageBonus += 15
    }
}

// Heal skill
rule use_skill_heal on UseSkill(us: id) {
let character: id = us.source
    if character.Skills.skill1 == "heal" && character.Mana.current >= 15 {
        character.Mana.current -= 15
        character.Health.current += 30
    }
}

// Backstab skill
rule use_skill_backstab on UseSkill(us: id) {
let character: id = us.source
    if character.Skills.skill1 == "backstab" {
        character.Combat.critChance += 0.25
    }
}

// Mana regeneration
rule mana_regen on ManaRegen(mr: id) {
let character: id = mr.source
    if character.Health.current > 0 {
        character.Mana.current += 5
        schedule [delay: 2] ManaRegen {
            source: character
        }
    }
}

// Spawn next enemy wave - REMOVED
// Wave spawning is now handled by handle_enemy_spawned rule which uses tiered progression

// Count player deaths
rule count_player_death on PlayerDefeated(pd: id) {
let gameStates: list = entities having GameState
    for gameState in gameStates {
        gameState.GameState.playerDeaths += 1
    }
}

// Apply death penalty to run stats
rule apply_death_penalty on PlayerDefeated(pd: id) {
let runStatsEntities: list = entities having RunStats
    for runStats in runStatsEntities {
let fleeConfigs: list = entities having FleeConfig
        if len(fleeConfigs) > 0 {
let fleeConfig: id = fleeConfigs[0]
            runStats.RunStats.deathPenalty += fleeConfig.FleeConfig.retreatTimePenalty * fleeConfig.FleeConfig.deathTimePenaltyMultiplier
            runStats.RunStats.totalTime = runStats.RunStats.simulationTime + runStats.RunStats.retreatPenalty + runStats.RunStats.deathPenalty
            schedule UpdateRunStats {
            }
        }
    }
}

// Game over on all players dead
// NOTE: Removed automatic game-over when all players die. The game
// now continues (players will respawn) and only finishes when the
// final boss (Lord Vexar) is defeated.

// Victory check - REMOVED
// Victory is now only achieved by defeating Lord Vexar (handled in boss_defeated_victory rule)
// The game continues even if all heroes die - they respawn after 120 seconds

// Acquire skill
rule acquire_skill on AcquireSkill(as: id) {
let character: id = as.source
    if character.Skills.skillPoints > 0 {
        character.Skills.skillPoints -= 1
        schedule SkillAcquired {
            character: character
        }
    }
}

// Flee from battle - player initiates retreat
rule flee_battle on FleeFromBattle(fb: id) {
    // Find the entity with RunStats
let runStatsEntities: list = entities having RunStats
let fleeConfigEntities: list = entities having FleeConfig
    
    if len(runStatsEntities) > 0 && len(fleeConfigEntities) > 0 {
let runStatsEntity: id = runStatsEntities[0]
let fleeConfigEntity: id = fleeConfigEntities[0]
        
        // Check cooldown
let timeSinceFlee: id = runStatsEntity.RunStats.simulationTime - runStatsEntity.RunStats.lastFleeTime
        if timeSinceFlee >= fleeConfigEntity.FleeConfig.fleeCooldown {
            // Apply retreat penalty
            runStatsEntity.RunStats.retreatCount += 1
            runStatsEntity.RunStats.retreatPenalty += fleeConfigEntity.FleeConfig.retreatTimePenalty
            runStatsEntity.RunStats.lastFleeTime = runStatsEntity.RunStats.simulationTime
            runStatsEntity.RunStats.canFlee = false
            runStatsEntity.RunStats.totalTime = runStatsEntity.RunStats.simulationTime + runStatsEntity.RunStats.retreatPenalty + runStatsEntity.RunStats.deathPenalty
            
            // Mark all enemies for despawn
            schedule DespawnAllEnemies {
            }
            
            // Find entity with GameState and SpawnConfig to target SpawnEnemyWave
let gameStateEntities: list = entities having GameState
            if len(gameStateEntities) > 0 {
                // Spawn new wave after retreat, targeting the GameState entity
                schedule [delay: 0.5] SpawnEnemyWave {
                    target: gameStateEntities[0]
                }
            }
            
            schedule UpdateRunStats {
            }
        }
    }
}

// Despawn all enemies on flee
rule despawn_enemies on DespawnAllEnemies(dae: id) {
let enemies: list = entities having Enemy
    for enemy in enemies {
        if enemy.Enemy.tier > 0 {
            // Remove enemy entity
            enemy.Health.current = 0
            schedule RemoveEntity {
                target: enemy
            }
        }
    }
}

// Spawn a new wave after fleeing
rule spawn_wave_after_flee on SpawnEnemyWave(sew: id) {
let spawner: id = sew.target
    // Trigger EnemySpawned to spawn the next wave
    // This reuses the existing wave spawning logic
    schedule [delay: 0.1] EnemySpawned {
        wave: spawner.GameState.currentWave
    }
}

// Update flee cooldown timer
rule update_flee_cooldown on UpdateRunStats(urs: id) {
let runStatsEntities: list = entities having RunStats
    for runStats in runStatsEntities {
let fleeConfigs: list = entities having FleeConfig
        if len(fleeConfigs) > 0 {
let fleeConfig: id = fleeConfigs[0]
let timeSinceFlee: id = runStats.RunStats.simulationTime - runStats.RunStats.lastFleeTime
            if timeSinceFlee >= fleeConfig.FleeConfig.fleeCooldown {
                runStats.RunStats.canFlee = true
            }
        }
    }
}

// Complete run and save to leaderboard
rule complete_run on GameOver(go: id) {
let runStatsEntities: list = entities having RunStats
    for runStats in runStatsEntities {
let gameStates: list = entities having GameState
        if len(gameStates) > 0 {
let gameState: id = gameStates[0]
            schedule SaveRunToLeaderboard {
                completionTime: runStats.RunStats.totalTime
                enemiesDefeated: gameState.GameState.enemiesDefeated
                playerDeaths: gameState.GameState.playerDeaths
                retreats: runStats.RunStats.retreatCount
                retreatPenalty: runStats.RunStats.retreatPenalty
                deathPenalty: runStats.RunStats.deathPenalty
                victory: gameState.GameState.victory
            }
        }
    }
}

// Start global recurring retargeting when game begins
rule start_global_retargeting on EnemySpawned(es: id) {
    // Only start retargeting once, when first enemy spawns
let gameStates: list = entities having GameState
    for gameState in gameStates {
        if gameState.GameState.currentWave == 1 {
            if gameState.GameState.retargetingActive == false {
                gameState.GameState.retargetingActive = true
                // Schedule first retargeting check in 2 seconds
                schedule [delay: 2.0] CheckAllTargets {
                }
            }
        }
    }
}

// Check if entity needs retargeting
rule check_entity_target on CheckAllTargets(cat: id) {
let entities_with_targets: list = entities having Target
    for ent in entities_with_targets {
        if ent.Health.current > 0 {
            // Skip enemy templates - they don't participate in combat
let isTemplate: boolean = false
let enemyTemplates: list = entities having EnemyTemplate
            for tmpl in enemyTemplates {
                if tmpl == ent && tmpl.EnemyTemplate.isTemplate {
                    isTemplate = true
                }
            }
            
            if isTemplate == false {
let target: id = ent.Target.entity
                if target == null || target.Health.current <= 0 {
                    schedule FindNewTarget {
                        seeker: ent
                    }
                }
            }
        }
    }
}

// Reschedule the next retargeting check (makes it recurring)
rule reschedule_retargeting on CheckAllTargets(cat: id) {
    // Only fire for entity with GameState component
let gameStates: list = entities having GameState
    for gameState in gameStates {
        if gameState.GameState.retargetingActive {
            if gameState.GameState.gameOver == false {
                // Schedule next check in 2 seconds
                schedule [delay: 2.0] CheckAllTargets {
                }
            }
        }
    }
}

// ============================================================================
// TARGET ASSIGNMENT RULES
// ============================================================================

// Find and assign a new target for an entity
rule find_new_target on FindNewTarget(fnt: id) {
let seeker: id = fnt.seeker
    
    // Determine if seeker is a player or enemy
    if seeker.Team.isPlayer {
        // Player characters target enemies
let enemies: list = entities having Enemy
let foundTarget: boolean = false
        for enemy in enemies {
            // Skip templates and only process if we haven't found a target yet
            if foundTarget == false {
let isTemplate: boolean = false
let templates: list = entities having EnemyTemplate
                for tmpl in templates {
                    if tmpl == enemy && tmpl.EnemyTemplate.isTemplate {
                        isTemplate = true
                    }
                }
                
                if isTemplate == false {
                    if enemy.Health.current > 0 {
                        // Found a valid target
                        seeker.Target.entity = enemy
                        // Schedule attack now that we have a target
                        schedule DoAttack {
                            source: seeker
                        }
                        foundTarget = true
                    }
                }
            }
        }
        // No valid enemy target found - clear target
        if foundTarget == false {
            seeker.Target.entity = null
        }
    } else {
        // Enemy characters target players
let players: list = entities having Team
let foundTarget: boolean = false
        for player in players {
            // Only process if we haven't found a target yet
            if foundTarget == false {
                if player.Team.isPlayer {
                    if player.Health.current > 0 {
                        // Found a valid target
                        seeker.Target.entity = player
                        // Schedule attack now that we have a target
                        schedule DoAttack {
                            source: seeker
                        }
                        foundTarget = true
                    }
                }
            }
        }
        // No valid player target found - clear target
        if foundTarget == false {
            seeker.Target.entity = null
        }
    }
}
