<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
  <meta http-equiv="Pragma" content="no-cache">
  <meta http-equiv="Expires" content="0">
  <title>Blink Idle RPG - Classic RPG Demo</title>
  <style>
    * {
      box-sizing: border-box;
    }
    
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #2d2520 0%, #3d3028 100%);
      color: #d4c4b0;
      margin: 0;
      padding: 10px;
      min-height: 100vh;
    }
    
    .container {
      max-width: 1400px;
      margin: 0 auto;
    }
    
    h1 {
      text-align: center;
      color: #c9956b;
      margin-bottom: 5px;
      font-size: 1.8rem;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
    }
    
    .subtitle {
      text-align: center;
      color: #8a7a68;
      margin-bottom: 15px;
      font-size: 0.9rem;
    }
    
    /* File upload section */
    .upload-section {
      background: rgba(255,255,255,0.05);
      border-radius: 15px;
      padding: 15px;
      margin-bottom: 15px;
      border: 2px solid rgba(255,255,255,0.1);
    }
    
    .upload-section h2 {
      color: #4ade80;
      margin-top: 0;
      font-size: 1.1rem;
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .accordion-toggle {
      font-size: 0.9rem;
      color: #888;
      transition: transform 0.3s ease;
    }
    
    .accordion-toggle.expanded {
      transform: rotate(180deg);
    }
    
    .upload-content {
      max-height: 0;
      overflow: hidden;
      transition: max-height 0.3s ease;
    }
    
    .upload-content.expanded {
      max-height: 500px;
    }
    
    .upload-row {
      display: flex;
      gap: 20px;
      flex-wrap: wrap;
      margin-bottom: 15px;
    }
    
    .upload-item {
      flex: 1;
      min-width: 250px;
    }
    
    .upload-item label {
      display: block;
      margin-bottom: 8px;
      color: #aaa;
    }
    
    .upload-item input[type="file"] {
      width: 100%;
      padding: 10px;
      background: rgba(0,0,0,0.3);
      border: 1px dashed rgba(255,255,255,0.3);
      border-radius: 8px;
      color: #eee;
      cursor: pointer;
    }
    
    .upload-item input[type="file"]:hover {
      border-color: #4ade80;
    }
    
    .file-status {
      font-size: 0.85rem;
      margin-top: 5px;
      color: #888;
    }
    
    .file-status.loaded {
      color: #4ade80;
    }
    
    .file-status.error {
      color: #f87171;
    }
    
    /* Game container */
    .game-container {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 15px;
      margin-bottom: 15px;
    }
    
    @media (max-width: 900px) {
      .game-container {
        grid-template-columns: 1fr;
      }
    }
    
    .team-section {
      background: rgba(255,255,255,0.05);
      border-radius: 15px;
      padding: 12px;
      border: 2px solid rgba(255,255,255,0.1);
    }
    
    .team-section.player-team {
      border-color: rgba(156, 168, 115, 0.4);
    }
    
    .team-section.enemy-team {
      border-color: rgba(168, 94, 82, 0.4);
    }
    
    .team-section h2 {
      margin-top: 0;
      margin-bottom: 10px;
      font-size: 1.1rem;
      display: flex;
      align-items: center;
      justify-content: space-between;
      cursor: pointer;
    }
    
    .team-summary {
      font-size: 0.85rem;
      color: #8a7a68;
      margin-bottom: 8px;
    }
    
    .team-content {
      max-height: 0;
      overflow: hidden;
      transition: max-height 0.3s ease;
    }
    
    .team-content.expanded {
      max-height: 1000px;
      overflow-y: auto;
    }
    
    .player-team h2 {
      color: #9ca873;
    }
    
    .enemy-team h2 {
      color: #a85e52;
    }
    
    /* Character cards */
    .character-card {
      background: rgba(0,0,0,0.3);
      border-radius: 8px;
      padding: 10px;
      margin-bottom: 8px;
      transition: all 0.3s ease;
    }
    
    .character-card.dead {
      opacity: 0.4;
      filter: grayscale(0.8);
    }
    
    .character-card.attacking {
      animation: attack-flash 0.2s ease;
    }
    
    @keyframes attack-flash {
      0%, 100% { background: rgba(0,0,0,0.3); }
      50% { background: rgba(255,255,255,0.1); }
    }
    
    .char-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 6px;
      cursor: pointer;
    }
    
    .char-name {
      font-weight: bold;
      font-size: 0.95rem;
    }
    
    .char-class {
      color: #888;
      font-size: 0.75rem;
    }
    
    .char-level {
      background: linear-gradient(135deg, #8b5cf6 0%, #6d28d9 100%);
      color: white;
      padding: 2px 8px;
      border-radius: 12px;
      font-size: 0.7rem;
    }
    
    .char-summary {
      margin-top: 5px;
    }
    
    .char-details {
      max-height: 0;
      overflow: hidden;
      transition: max-height 0.3s ease;
    }
    
    .char-details.expanded {
      max-height: 300px;
      margin-top: 6px;
    }
    
    .stat-bar {
      margin-bottom: 5px;
    }
    
    .stat-bar-header {
      display: flex;
      justify-content: space-between;
      font-size: 0.75rem;
      margin-bottom: 2px;
    }
    
    .bar-container {
      background: rgba(0,0,0,0.5);
      border-radius: 4px;
      height: 10px;
      overflow: hidden;
    }
    
    .bar-fill {
      height: 100%;
      border-radius: 4px;
      transition: width 0.3s ease;
    }
    
    .health-bar {
      background: linear-gradient(90deg, #9ca873 0%, #b0bd8a 100%);
    }
    
    .mana-bar {
      background: linear-gradient(90deg, #7b93a8 0%, #8fa5b8 100%);
    }
    
    .exp-bar {
      background: linear-gradient(90deg, #c9956b 0%, #d4a77d 100%);
    }
    
    .char-stats {
      display: flex;
      gap: 10px;
      font-size: 0.75rem;
      color: #aaa;
      margin-top: 5px;
    }
    
    .char-stats span {
      display: flex;
      align-items: center;
      gap: 4px;
    }
    
    .skills-row {
      display: flex;
      gap: 4px;
      margin-top: 5px;
      flex-wrap: wrap;
    }
    
    .skill-badge {
      background: rgba(139, 92, 246, 0.3);
      color: #c4b5fd;
      padding: 1px 6px;
      border-radius: 3px;
      font-size: 0.7rem;
    }
    
    /* Controls */
    .controls {
      text-align: center;
      margin-bottom: 15px;
    }
    
    button {
      background: linear-gradient(135deg, #c9956b 0%, #a8845f 100%);
      color: #2d2520;
      border: none;
      padding: 8px 20px;
      font-size: 0.9rem;
      border-radius: 8px;
      cursor: pointer;
      margin: 0 5px;
      transition: all 0.3s ease;
      font-weight: bold;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    
    button:hover:not(:disabled) {
      transform: translateY(-2px);
      box-shadow: 0 5px 20px rgba(201, 149, 107, 0.4);
    }
    
    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    
    button.secondary {
      background: linear-gradient(135deg, #8a7a68 0%, #6b5e52 100%);
      color: #d4c4b0;
    }
    
    button.secondary:hover:not(:disabled) {
      box-shadow: 0 5px 20px rgba(138, 122, 104, 0.4);
    }
    
    button.success {
      background: linear-gradient(135deg, #9ca873 0%, #8a9565 100%);
      color: #2d2520;
    }
    
    /* Status bar */
    .status-bar {
      display: flex;
      justify-content: center;
      gap: 15px;
      margin-bottom: 10px;
      padding: 8px;
      background: rgba(0,0,0,0.2);
      border-radius: 8px;
      flex-wrap: wrap;
    }
    
    .status-item {
      display: flex;
      align-items: center;
      gap: 5px;
      font-size: 0.85rem;
    }
    
    .status-label {
      color: #8a7a68;
    }
    
    .status-value {
      font-weight: bold;
      color: #c9956b;
    }
    
    /* Game state banner */
    .game-banner {
      text-align: center;
      padding: 20px;
      border-radius: 10px;
      margin-bottom: 20px;
      display: none;
    }
    
    .game-banner.victory {
      background: linear-gradient(135deg, rgba(74, 222, 128, 0.2) 0%, rgba(34, 197, 94, 0.2) 100%);
      border: 2px solid #4ade80;
      animation: pulse 2s infinite;
    }
    
    .game-banner.defeat {
      background: linear-gradient(135deg, rgba(248, 113, 113, 0.2) 0%, rgba(239, 68, 68, 0.2) 100%);
      border: 2px solid #f87171;
    }
    
    @keyframes pulse {
      0%, 100% { box-shadow: 0 0 0 0 rgba(74, 222, 128, 0.4); }
      50% { box-shadow: 0 0 20px 10px rgba(74, 222, 128, 0); }
    }
    
    .game-banner h2 {
      margin: 0;
      font-size: 1.8rem;
    }
    
    .victory h2 { color: #4ade80; }
    .defeat h2 { color: #f87171; }
    
    /* Combat log */
    .combat-log {
      background: rgba(0,0,0,0.3);
      border-radius: 15px;
      padding: 12px;
      max-height: 180px;
      overflow-y: auto;
    }
    
    .combat-log h2 {
      margin-top: 0;
      color: #e94560;
      font-size: 1.1rem;
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .log-content {
      max-height: 0;
      overflow: hidden;
      transition: max-height 0.3s ease;
    }
    
    .log-content.expanded {
      max-height: 160px;
      overflow-y: auto;
      margin-top: 8px;
    }
    
    .log-entry {
      padding: 5px 8px;
      margin: 3px 0;
      border-radius: 4px;
      font-size: 0.8rem;
      animation: fadeIn 0.3s ease;
    }
    
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(-10px); }
      to { opacity: 1; transform: translateY(0); }
    }
    
    .log-entry.attack { background: rgba(251, 191, 36, 0.1); border-left: 3px solid #fbbf24; }
    .log-entry.damage { background: rgba(239, 68, 68, 0.1); border-left: 3px solid #ef4444; }
    .log-entry.death { background: rgba(139, 92, 246, 0.1); border-left: 3px solid #8b5cf6; }
    .log-entry.system { background: rgba(59, 130, 246, 0.1); border-left: 3px solid #3b82f6; }
    .log-entry.levelup { background: rgba(74, 222, 128, 0.1); border-left: 3px solid #4ade80; }
    .log-entry.skill { background: rgba(236, 72, 153, 0.1); border-left: 3px solid #ec4899; }
    
    .log-time {
      color: #888;
      font-size: 0.8rem;
      margin-right: 10px;
    }
    
    /* Speed control */
    .speed-control {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 10px;
      margin-bottom: 10px;
      font-size: 0.85rem;
    }
    
    .speed-control label {
      color: #888;
    }
    
    .speed-control input[type="range"] {
      width: 200px;
      accent-color: #e94560;
    }
    
    /* Party Selection Screen */
    #party-selection-screen {
      background: rgba(0,0,0,0.3);
      border-radius: 15px;
      padding: 20px;
      margin-bottom: 20px;
    }
    
    #party-selection-screen h2 {
      color: #c9956b;
      text-align: center;
      margin-top: 0;
      font-size: 1.4rem;
    }
    
    .selection-instructions {
      text-align: center;
      color: #8a7a68;
      margin-bottom: 20px;
      font-size: 0.9rem;
    }
    
    .slots-container {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
      gap: 20px;
      margin-bottom: 25px;
    }
    
    @media (max-width: 900px) {
      .slots-container {
        grid-template-columns: 1fr 1fr;
      }
    }
    
    @media (max-width: 640px) {
      .slots-container {
        grid-template-columns: 1fr;
      }
    }
    
    .hero-slot {
      background: rgba(0,0,0,0.4);
      border: 2px solid rgba(201, 149, 107, 0.3);
      border-radius: 10px;
      padding: 15px;
      transition: all 0.3s ease;
    }
    
    .hero-slot.active {
      border-color: #c9956b;
      box-shadow: 0 0 20px rgba(201, 149, 107, 0.3);
    }
    
    .slot-header {
      text-align: center;
      margin-bottom: 12px;
      padding-bottom: 10px;
      border-bottom: 1px solid rgba(201, 149, 107, 0.2);
    }
    
    .slot-title {
      color: #c9956b;
      font-size: 1rem;
      font-weight: bold;
      margin: 0;
    }
    
    .carousel-container {
      position: relative;
      min-height: 380px;
    }
    
    .carousel-controls {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
    }
    
    .carousel-btn {
      background: rgba(201, 149, 107, 0.2);
      border: 1px solid rgba(201, 149, 107, 0.4);
      color: #c9956b;
      width: 36px;
      height: 36px;
      border-radius: 50%;
      cursor: pointer;
      font-size: 1.2rem;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.3s ease;
      padding: 0;
      margin: 0;
    }
    
    .carousel-btn:hover:not(:disabled) {
      background: rgba(201, 149, 107, 0.4);
      transform: scale(1.1);
      box-shadow: none;
    }
    
    .carousel-btn:disabled {
      opacity: 0.3;
      cursor: not-allowed;
    }
    
    .carousel-indicator {
      color: #8a7a68;
      font-size: 0.85rem;
      flex: 1;
      text-align: center;
    }
    
    .hero-card {
      background: rgba(0,0,0,0.3);
      border-radius: 8px;
      padding: 12px;
      transition: all 0.3s ease;
    }
    
    .hero-card.unavailable {
      opacity: 0.5;
      position: relative;
    }
    
    .hero-card.unavailable::after {
      content: '‚úì Already Selected';
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0,0,0,0.9);
      color: #c9956b;
      padding: 8px 16px;
      border-radius: 6px;
      font-weight: bold;
      font-size: 0.9rem;
    }
    
    .character-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
    }
    
    .character-title {
      flex: 1;
    }
    
    .character-title h3 {
      margin: 0;
      color: #c9956b;
      font-size: 1.05rem;
    }
    
    .character-title .character-class {
      color: #8a7a68;
      font-size: 0.8rem;
    }
    
    .character-description {
      color: #a99885;
      font-size: 0.85rem;
      line-height: 1.4;
      margin-bottom: 10px;
    }
    
    .character-role {
      display: inline-block;
      background: rgba(201, 149, 107, 0.2);
      color: #c9956b;
      padding: 3px 8px;
      border-radius: 4px;
      font-size: 0.75rem;
      margin-right: 5px;
      margin-bottom: 5px;
    }
    
    .character-stats-preview {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 5px;
      margin-top: 10px;
      font-size: 0.8rem;
    }
    
    .stat-preview {
      display: flex;
      justify-content: space-between;
      padding: 3px 0;
      color: #8a7a68;
    }
    
    .stat-preview-value {
      color: #c9956b;
      font-weight: bold;
    }
    
    .party-counter {
      text-align: center;
      font-size: 1.1rem;
      margin-bottom: 15px;
      color: #c9956b;
    }
    
    .start-game-btn {
      display: block;
      width: 100%;
      max-width: 400px;
      margin: 0 auto;
      padding: 15px;
      font-size: 1.1rem;
      background: linear-gradient(135deg, #c9956b 0%, #a8845f 100%);
      color: #2d2520;
      border: none;
      border-radius: 10px;
      cursor: pointer;
      font-weight: bold;
      text-transform: uppercase;
      letter-spacing: 1px;
      transition: all 0.3s ease;
    }
    
    .start-game-btn:hover:not(:disabled) {
      transform: translateY(-2px);
      box-shadow: 0 5px 20px rgba(201, 149, 107, 0.4);
    }
    
    .start-game-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    
    #game-screen {
      display: none;
    }
    
    #game-screen.active {
      display: block;
    }
    
    /* BCL info panel */
    .bcl-info {
      background: rgba(139, 92, 246, 0.1);
      border: 1px solid rgba(139, 92, 246, 0.3);
      border-radius: 10px;
      padding: 15px;
      margin-top: 15px;
    }
    
    .bcl-info h3 {
      margin-top: 0;
      color: #c4b5fd;
      font-size: 1rem;
    }
    
    .bcl-file-list {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
    }
    
    .bcl-file-item {
      background: rgba(0,0,0,0.3);
      padding: 5px 10px;
      border-radius: 5px;
      font-size: 0.85rem;
    }
    
    /* Leaderboard Styles */
    .leaderboard-panel {
      background: rgba(255,255,255,0.05);
      border-radius: 15px;
      padding: 15px;
      margin-bottom: 15px;
      border: 2px solid rgba(201, 149, 107, 0.3);
    }
    
    .leaderboard-panel h2 {
      color: #c9956b;
      margin-top: 0;
      font-size: 1.2rem;
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .leaderboard-content {
      max-height: 0;
      overflow: hidden;
      transition: max-height 0.3s ease;
    }
    
    .leaderboard-content.expanded {
      max-height: 600px;
      overflow-y: auto;
    }
    
    .leaderboard-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.85rem;
      margin-top: 10px;
    }
    
    .leaderboard-table th {
      background: rgba(0,0,0,0.3);
      color: #c9956b;
      padding: 8px;
      text-align: left;
      border-bottom: 2px solid rgba(201, 149, 107, 0.3);
    }
    
    .leaderboard-table td {
      padding: 8px;
      border-bottom: 1px solid rgba(255,255,255,0.1);
    }
    
    .leaderboard-table tr:hover {
      background: rgba(255,255,255,0.05);
    }
    
    .leaderboard-rank {
      font-weight: bold;
      color: #c9956b;
    }
    
    .leaderboard-rank.gold { color: #fbbf24; }
    .leaderboard-rank.silver { color: #d1d5db; }
    .leaderboard-rank.bronze { color: #f59e0b; }
    
    .leaderboard-actions {
      display: flex;
      gap: 10px;
      margin-top: 10px;
    }
    
    .leaderboard-empty {
      text-align: center;
      color: #8a7a68;
      padding: 20px;
      font-style: italic;
    }
    
    /* Run Statistics */
    .run-stats {
      background: rgba(139, 92, 246, 0.1);
      border: 1px solid rgba(139, 92, 246, 0.3);
      border-radius: 10px;
      padding: 12px;
      margin-bottom: 15px;
    }
    
    .run-stats h3 {
      margin: 0 0 10px 0;
      color: #c4b5fd;
      font-size: 0.9rem;
    }
    
    .run-stats-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 8px;
    }
    
    .run-stat-item {
      background: rgba(0,0,0,0.3);
      padding: 8px;
      border-radius: 5px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .run-stat-label {
      color: #8a7a68;
      font-size: 0.75rem;
    }
    
    .run-stat-value {
      color: #c9956b;
      font-weight: bold;
      font-size: 0.85rem;
    }
    
    .run-stat-penalty {
      color: #f87171;
    }
    
    /* Flee Button */
    button.flee {
      background: linear-gradient(135deg, #fbbf24 0%, #f59e0b 100%);
      color: #2d2520;
    }
    
    button.flee:hover:not(:disabled) {
      box-shadow: 0 5px 20px rgba(251, 191, 36, 0.4);
    }
    
    .flee-cooldown {
      font-size: 0.7rem;
      color: #888;
      margin-left: 5px;
    }
    
    /* Dev Mode Styles */
    .dev-mode-panel {
      background: rgba(139, 92, 246, 0.1);
      border: 2px solid rgba(139, 92, 246, 0.4);
      border-radius: 15px;
      padding: 15px;
      margin-bottom: 15px;
      display: none;
    }
    
    .dev-mode-panel.active {
      display: block;
    }
    
    .dev-mode-panel h2 {
      color: #c4b5fd;
      margin-top: 0;
      font-size: 1.2rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
      cursor: pointer;
    }
    
    .dev-mode-toggle {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 10px;
    }
    
    .dev-mode-toggle button {
      background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%);
      color: white;
    }
    
    .dev-mode-toggle button.active {
      background: linear-gradient(135deg, #4ade80 0%, #22c55e 100%);
    }
    
    .source-viewer {
      background: #1a1a2e;
      border-radius: 10px;
      padding: 15px;
      font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
      font-size: 0.85rem;
      max-height: 400px;
      overflow-y: auto;
      margin-top: 10px;
    }
    
    .source-viewer pre {
      margin: 0;
      white-space: pre-wrap;
      word-wrap: break-word;
    }
    
    .source-line {
      display: flex;
      align-items: flex-start;
      padding: 2px 0;
      transition: background 0.2s;
    }
    
    .source-line.highlighted {
      background: rgba(251, 191, 36, 0.3);
      border-left: 3px solid #fbbf24;
      padding-left: 5px;
      margin-left: -8px;
    }
    
    .source-line.active {
      background: rgba(74, 222, 128, 0.3);
      border-left: 3px solid #4ade80;
      padding-left: 5px;
      margin-left: -8px;
    }
    
    .line-number {
      color: #666;
      min-width: 40px;
      text-align: right;
      padding-right: 15px;
      user-select: none;
    }
    
    .line-content {
      color: #e2e8f0;
    }
    
    .source-file-tabs {
      display: flex;
      gap: 5px;
      margin-bottom: 10px;
      flex-wrap: wrap;
    }
    
    .source-file-tab {
      background: rgba(0,0,0,0.3);
      color: #8a7a68;
      padding: 5px 10px;
      border-radius: 5px 5px 0 0;
      border: none;
      cursor: pointer;
      font-size: 0.8rem;
      transition: all 0.3s;
    }
    
    .source-file-tab.active {
      background: #1a1a2e;
      color: #c4b5fd;
    }
    
    .source-file-tab:hover {
      color: #c4b5fd;
    }
    
    .debug-controls {
      display: flex;
      gap: 10px;
      margin: 10px 0;
      flex-wrap: wrap;
      align-items: center;
    }
    
    .debug-controls button {
      padding: 6px 12px;
      font-size: 0.8rem;
    }
    
    .debug-info {
      background: rgba(0,0,0,0.3);
      padding: 10px;
      border-radius: 5px;
      margin-top: 10px;
      font-size: 0.8rem;
    }
    
    .debug-info-item {
      display: flex;
      justify-content: space-between;
      padding: 3px 0;
      border-bottom: 1px solid rgba(255,255,255,0.1);
    }
    
    .debug-info-item:last-child {
      border-bottom: none;
    }
    
    .debug-info-label {
      color: #8a7a68;
    }
    
    .debug-info-value {
      color: #c4b5fd;
      font-family: 'Consolas', 'Monaco', monospace;
    }
    
    /* Syntax highlighting */
    .keyword { color: #c792ea; }
    .string { color: #c3e88d; }
    .number { color: #f78c6c; }
    .comment { color: #6a737d; font-style: italic; }
    .component { color: #82aaff; }
    .rule { color: #ffcb6b; }
    .entity { color: #89ddff; }
    
    /* BCL Customization Modal */
    .bcl-modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.85);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      backdrop-filter: blur(5px);
    }
    
    .bcl-modal-overlay.active {
      display: flex;
    }
    
    .bcl-modal {
      background: linear-gradient(135deg, #2d2520 0%, #3d3028 100%);
      border: 2px solid rgba(201, 149, 107, 0.4);
      border-radius: 15px;
      width: 90%;
      max-width: 900px;
      max-height: 90vh;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      box-shadow: 0 10px 50px rgba(0, 0, 0, 0.5);
    }
    
    .bcl-modal-header {
      padding: 15px 20px;
      border-bottom: 1px solid rgba(201, 149, 107, 0.3);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .bcl-modal-header h2 {
      margin: 0;
      color: #c9956b;
      font-size: 1.3rem;
    }
    
    .bcl-modal-close {
      background: transparent;
      border: none;
      color: #8a7a68;
      font-size: 1.5rem;
      cursor: pointer;
      padding: 5px 10px;
      border-radius: 5px;
      transition: all 0.3s;
    }
    
    .bcl-modal-close:hover {
      background: rgba(255, 255, 255, 0.1);
      color: #d4c4b0;
    }
    
    .bcl-modal-body {
      flex: 1;
      overflow-y: auto;
      padding: 20px;
      display: flex;
      gap: 20px;
    }
    
    @media (max-width: 768px) {
      .bcl-modal-body {
        flex-direction: column;
      }
    }
    
    .bcl-choices-list {
      width: 280px;
      min-width: 280px;
      border-right: 1px solid rgba(201, 149, 107, 0.2);
      padding-right: 20px;
    }
    
    @media (max-width: 768px) {
      .bcl-choices-list {
        width: 100%;
        min-width: auto;
        border-right: none;
        border-bottom: 1px solid rgba(201, 149, 107, 0.2);
        padding-right: 0;
        padding-bottom: 15px;
      }
    }
    
    .bcl-choices-list h3 {
      margin: 0 0 15px 0;
      color: #c4b5fd;
      font-size: 1rem;
    }
    
    .choice-item {
      padding: 12px;
      background: rgba(0, 0, 0, 0.3);
      border-radius: 8px;
      margin-bottom: 10px;
      cursor: pointer;
      border: 2px solid transparent;
      transition: all 0.3s;
    }
    
    .choice-item:hover {
      background: rgba(0, 0, 0, 0.4);
      border-color: rgba(201, 149, 107, 0.3);
    }
    
    .choice-item.selected {
      border-color: #c9956b;
      background: rgba(201, 149, 107, 0.1);
    }
    
    .choice-item.customized {
      position: relative;
    }
    
    .choice-item.customized::after {
      content: '‚úèÔ∏è Customized';
      position: absolute;
      top: 8px;
      right: 8px;
      font-size: 0.7rem;
      color: #4ade80;
      background: rgba(74, 222, 128, 0.1);
      padding: 2px 6px;
      border-radius: 3px;
    }
    
    .choice-item-name {
      font-weight: bold;
      color: #c9956b;
      margin-bottom: 4px;
    }
    
    .choice-item-category {
      font-size: 0.75rem;
      color: #8a7a68;
      background: rgba(0, 0, 0, 0.3);
      padding: 2px 6px;
      border-radius: 3px;
      display: inline-block;
      margin-bottom: 6px;
    }
    
    .choice-item-description {
      font-size: 0.8rem;
      color: #a99885;
      line-height: 1.4;
    }
    
    .bcl-editor-panel {
      flex: 1;
      display: flex;
      flex-direction: column;
    }
    
    .bcl-editor-header {
      margin-bottom: 15px;
    }
    
    .bcl-editor-header h3 {
      margin: 0 0 8px 0;
      color: #c9956b;
    }
    
    .bcl-editor-signature {
      font-family: 'Consolas', 'Monaco', monospace;
      font-size: 0.85rem;
      color: #c4b5fd;
      background: rgba(0, 0, 0, 0.3);
      padding: 10px;
      border-radius: 5px;
      margin-bottom: 10px;
      overflow-x: auto;
    }
    
    .bcl-editor-docstring {
      font-size: 0.85rem;
      color: #a99885;
      font-style: italic;
      margin-bottom: 15px;
      padding: 10px;
      background: rgba(139, 92, 246, 0.1);
      border-left: 3px solid #8b5cf6;
      border-radius: 0 5px 5px 0;
    }
    
    .bcl-editor-textarea {
      flex: 1;
      min-height: 200px;
      background: #1a1a2e;
      border: 1px solid rgba(201, 149, 107, 0.3);
      border-radius: 8px;
      padding: 15px;
      font-family: 'Consolas', 'Monaco', monospace;
      font-size: 0.9rem;
      color: #e2e8f0;
      resize: vertical;
      line-height: 1.5;
    }
    
    .bcl-editor-textarea:focus {
      outline: none;
      border-color: #c9956b;
      box-shadow: 0 0 10px rgba(201, 149, 107, 0.2);
    }
    
    .bcl-editor-actions {
      display: flex;
      gap: 10px;
      margin-top: 15px;
      flex-wrap: wrap;
    }
    
    .bcl-editor-actions button {
      padding: 8px 16px;
      font-size: 0.85rem;
    }
    
    .bcl-editor-default {
      margin-top: 15px;
      padding: 10px;
      background: rgba(0, 0, 0, 0.3);
      border-radius: 5px;
    }
    
    .bcl-editor-default-label {
      font-size: 0.75rem;
      color: #8a7a68;
      margin-bottom: 5px;
    }
    
    .bcl-editor-default-text {
      font-size: 0.8rem;
      color: #a99885;
    }
    
    .bcl-modal-footer {
      padding: 15px 20px;
      border-top: 1px solid rgba(201, 149, 107, 0.3);
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-wrap: wrap;
      gap: 10px;
    }
    
    .bcl-footer-info {
      font-size: 0.8rem;
      color: #8a7a68;
    }
    
    .bcl-footer-actions {
      display: flex;
      gap: 10px;
    }
    
    /* Customize button on hero card */
    .hero-customize-btn {
      display: block;
      width: 100%;
      margin-top: 10px;
      padding: 8px;
      background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%);
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      font-size: 0.85rem;
      font-weight: bold;
      transition: all 0.3s;
    }
    
    .hero-customize-btn:hover {
      transform: translateY(-1px);
      box-shadow: 0 3px 10px rgba(139, 92, 246, 0.4);
    }
    
    .hero-customize-btn.has-customizations {
      background: linear-gradient(135deg, #4ade80 0%, #22c55e 100%);
    }
    
    .hero-customize-btn.has-customizations:hover {
      box-shadow: 0 3px 10px rgba(74, 222, 128, 0.4);
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>‚öîÔ∏è Blink Idle RPG</h1>
    <p class="subtitle">Classic RPG Demo - Heroes vs Monsters Battle!</p>
    
    <!-- Party Selection Screen -->
    <div id="party-selection-screen">
      <h2>‚öîÔ∏è Choose Your Party ‚öîÔ∏è</h2>
      <p class="selection-instructions">
        Select a hero for each of the 4 slots. Use the arrows to browse through available heroes. You cannot select the same hero twice.
      </p>
      
      <div class="party-counter">
        Selected: <span id="selected-count">0</span> / 4
      </div>
      
      <div class="slots-container" id="slots-container">
        <!-- Slots will be loaded dynamically -->
      </div>
      
      <button class="start-game-btn" id="confirm-party-btn" disabled>
        üéÆ Start Adventure
      </button>
    </div>
    
    <!-- Game Screen (hidden until party selected) -->
    <div id="game-screen">
    
    <!-- File Upload Section -->
    <div class="upload-section" style="display: none;">
      <h2 onclick="toggleAccordion('upload-content')">
        <span>üìÅ Load Game Files</span>
        <span class="accordion-toggle" id="upload-content-toggle">‚ñº</span>
      </h2>
      <div class="upload-content" id="upload-content">
        <div class="upload-row">
          <div class="upload-item">
            <label for="ir-file">Game Rules (IR JSON file):</label>
            <input type="file" id="ir-file" accept=".json,.ir.json">
            <div class="file-status" id="ir-status">Loading game rules...</div>
          </div>
          <div class="upload-item">
            <label for="bcl-file">Player Choices (BCL ZIP file):</label>
            <input type="file" id="bcl-file" accept=".zip">
            <div class="file-status" id="bcl-status">No file loaded - using default strategies</div>
          </div>
        </div>
        <div class="bcl-info" id="bcl-info" style="display: none;">
          <h3>üìú Loaded BCL Files:</h3>
          <div class="bcl-file-list" id="bcl-file-list"></div>
        </div>
        
        <!-- Download Links -->
        <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid rgba(255,255,255,0.1);">
          <h3 style="color: #c9956b; margin-bottom: 8px; font-size: 0.9rem;">üì¶ Download Example Files</h3>
          <p style="color: #8a7a68; font-size: 0.75rem; margin-bottom: 8px;">Study or modify these game files:</p>
          <div style="display: flex; gap: 8px; flex-wrap: wrap; margin-bottom: 8px;">
            <a href="../data/classic-rpg.ir.json" download style="background: rgba(0,0,0,0.3); padding: 6px 10px; border-radius: 5px; text-decoration: none; color: #7b93a8; font-size: 0.75rem; border: 1px solid rgba(123, 147, 168, 0.3); transition: all 0.3s; display: inline-block;">
              üìã classic-rpg.ir.json
            </a>
            <a href="party-config.bcl.zip" download style="background: rgba(0,0,0,0.3); padding: 6px 10px; border-radius: 5px; text-decoration: none; color: #9ca873; font-size: 0.75rem; border: 1px solid rgba(156, 168, 115, 0.3); transition: all 0.3s; display: inline-block;">
              üì¶ party-config.bcl.zip
            </a>
          </div>
          <p style="color: #8a7a68; font-size: 0.7rem; margin-top: 8px; margin-bottom: 0;">
            üí° <strong>IR files</strong> define game rules. <strong>BCL files</strong> define AI strategies.
          </p>
        </div>
      </div>
    </div>
    
    <!-- Status Bar -->
    <div class="status-bar">
      <div class="status-item">
        <span class="status-label">‚è±Ô∏è Sim Time:</span>
        <span class="status-value" id="game-time">0.00s</span>
      </div>
      <div class="status-item">
        <span class="status-label">‚è≥ Total Time:</span>
        <span class="status-value" id="total-time">0.00s</span>
      </div>
      <div class="status-item">
        <span class="status-label">üìä Wave:</span>
        <span class="status-value" id="current-wave">1</span>
      </div>
      <div class="status-item">
        <span class="status-label">üíÄ Enemies Defeated:</span>
        <span class="status-value" id="enemies-defeated">0</span>
      </div>
      <div class="status-item">
        <span class="status-label">‚ò†Ô∏è Player Deaths:</span>
        <span class="status-value" id="player-deaths">0</span>
      </div>
      <div class="status-item">
        <span class="status-label">üéÆ Status:</span>
        <span class="status-value" id="game-status">Ready</span>
      </div>
    </div>
    
    <!-- Run Statistics -->
    <div class="run-stats">
      <h3>üìä Current Run Statistics</h3>
      <div class="run-stats-grid">
        <div class="run-stat-item">
          <span class="run-stat-label">üèÉ Retreats:</span>
          <span class="run-stat-value" id="retreat-count">0</span>
        </div>
        <div class="run-stat-item">
          <span class="run-stat-label">‚è±Ô∏è Retreat Penalty:</span>
          <span class="run-stat-value run-stat-penalty" id="retreat-penalty">0s</span>
        </div>
        <div class="run-stat-item">
          <span class="run-stat-label">üíÄ Death Penalty:</span>
          <span class="run-stat-value run-stat-penalty" id="death-penalty">0s</span>
        </div>
        <div class="run-stat-item">
          <span class="run-stat-label">‚è≥ Total Penalties:</span>
          <span class="run-stat-value run-stat-penalty" id="total-penalties">0s</span>
        </div>
      </div>
    </div>
    
    <!-- Game Banner -->
    <div class="game-banner" id="game-banner">
      <h2 id="banner-text">üéâ Victory! üéâ</h2>
    </div>
    
    <!-- Game Container -->
    <div class="game-container">
      <!-- Player Team -->
      <div class="team-section player-team">
        <h2 onclick="toggleAccordion('player-party-content')">
          <div>
            <span>üõ°Ô∏è Your Party</span>
            <div class="team-summary" id="player-summary">4 Heroes</div>
          </div>
          <span class="accordion-toggle expanded" id="player-party-content-toggle">‚ñº</span>
        </h2>
        <div class="team-content expanded" id="player-party-content">
          <div id="player-party"></div>
        </div>
      </div>
      
      <!-- Enemy Team -->
      <div class="team-section enemy-team">
        <h2 onclick="toggleAccordion('enemy-party-content')">
          <div>
            <span>üëπ Enemies</span>
            <div class="team-summary" id="enemy-summary">5 Monsters</div>
          </div>
          <span class="accordion-toggle expanded" id="enemy-party-content-toggle">‚ñº</span>
        </h2>
        <div class="team-content expanded" id="enemy-party-content">
          <div id="enemy-party"></div>
        </div>
      </div>
    </div>
    
    <!-- Speed Control -->
    <div class="speed-control">
      <label for="speed-slider">Simulation Speed:</label>
      <input type="range" id="speed-slider" min="1" max="1000" step="10" value="100">
      <span id="speed-value">100x</span>
    </div>
    
    <!-- Controls -->
    <div class="controls">
      <button id="start-btn">‚ñ∂Ô∏è Start Battle</button>
      <button id="pause-btn" class="secondary" disabled>‚è∏Ô∏è Pause</button>
      <button id="flee-btn" class="flee" disabled>üèÉ Flee Battle</button>
      <button id="reset-btn" class="secondary">üîÑ Reset</button>
      <button id="dev-mode-btn" class="secondary">üõ†Ô∏è Dev Mode</button>
    </div>
    
    <!-- Dev Mode Panel -->
    <div class="dev-mode-panel" id="dev-mode-panel">
      <h2 onclick="toggleAccordion('dev-mode-content')">
        <span>üõ†Ô∏è Dev Mode - Integrated IDE</span>
        <span class="accordion-toggle expanded" id="dev-mode-content-toggle">‚ñº</span>
      </h2>
      <div class="dev-mode-content expanded" id="dev-mode-content">
        <div class="debug-controls">
          <button id="step-btn" class="secondary">‚è≠Ô∏è Step</button>
          <button id="step-10-btn" class="secondary">‚è≠Ô∏è x10</button>
          <button id="step-100-btn" class="secondary">‚è≠Ô∏è x100</button>
          <span style="color: #8a7a68; font-size: 0.85rem;">| Step through BRL/BCL/BDL execution</span>
        </div>
        
        <div class="debug-info" id="debug-info">
          <div class="debug-info-item">
            <span class="debug-info-label">Current Rule:</span>
            <span class="debug-info-value" id="debug-rule">-</span>
          </div>
          <div class="debug-info-item">
            <span class="debug-info-label">Event Type:</span>
            <span class="debug-info-value" id="debug-event">-</span>
          </div>
          <div class="debug-info-item">
            <span class="debug-info-label">Source Location:</span>
            <span class="debug-info-value" id="debug-location">-</span>
          </div>
        </div>
        
        <div class="source-file-tabs" id="source-file-tabs">
          <button class="source-file-tab active" data-file="brl">üìã BRL Rules</button>
          <button class="source-file-tab" data-file="bcl">üìú BCL Strategy</button>
          <button class="source-file-tab" data-file="bdl">üì¶ BDL Data</button>
        </div>
        
        <div class="source-viewer" id="source-viewer">
          <pre id="source-code">// Select a file tab above to view source code
// Enable dev mode and step through execution to see highlighted lines</pre>
        </div>
      </div>
    </div>
    
    <!-- Combat Log -->
    <div class="combat-log">
      <h2 onclick="toggleAccordion('log-content')">
        <span>üìú Combat Log</span>
        <span class="accordion-toggle" id="log-content-toggle">‚ñº</span>
      </h2>
      <div class="log-content" id="log-content">
        <div id="log-container">
          <div class="log-entry system">
            <span class="log-time">[0.00s]</span>
            <span>Waiting for battle to start...</span>
          </div>
        </div>
      </div>
    </div>
    
    <!-- Leaderboard -->
    <div class="leaderboard-panel">
      <h2 onclick="toggleAccordion('leaderboard-content')">
        <span>üèÜ Leaderboard - Best Party Builds</span>
        <span class="accordion-toggle" id="leaderboard-content-toggle">‚ñº</span>
      </h2>
      <div class="leaderboard-content" id="leaderboard-content">
        <div class="leaderboard-actions">
          <button class="secondary" onclick="refreshLeaderboard()">üîÑ Refresh</button>
          <button class="secondary" onclick="clearLeaderboard()">üóëÔ∏è Clear All</button>
          <button class="secondary" onclick="exportLeaderboard()">üíæ Export</button>
        </div>
        <div id="leaderboard-table-container">
          <div class="leaderboard-empty">
            No runs recorded yet. Complete a game to see your build on the leaderboard!
          </div>
        </div>
      </div>
    </div>
    
    </div><!-- End of game-screen -->
  </div><!-- End of container -->

  <!-- BCL Customization Modal -->
  <div class="bcl-modal-overlay" id="bcl-modal-overlay" role="dialog" aria-modal="true" aria-labelledby="bcl-modal-title">
    <div class="bcl-modal">
      <div class="bcl-modal-header">
        <h2 id="bcl-modal-title">üéØ Customize <span id="bcl-modal-hero-name">Hero</span> Strategy</h2>
        <button class="bcl-modal-close" onclick="closeBclModal()" aria-label="Close modal">√ó</button>
      </div>
      <div class="bcl-modal-body">
        <div class="bcl-choices-list">
          <h3>üìã Available Choices</h3>
          <div id="bcl-choices-container" role="listbox" aria-label="Available choice points">
            <!-- Choice items will be populated here -->
          </div>
        </div>
        <div class="bcl-editor-panel">
          <div class="bcl-editor-header">
            <h3 id="bcl-editor-title">Select a choice to customize</h3>
            <div class="bcl-editor-signature" id="bcl-editor-signature" style="display: none;"></div>
            <div class="bcl-editor-docstring" id="bcl-editor-docstring" style="display: none;"></div>
          </div>
          <textarea class="bcl-editor-textarea" id="bcl-editor-textarea" placeholder="Select a choice from the list to start editing..." aria-label="BCL code editor"></textarea>
          <div class="bcl-editor-actions">
            <button class="success" onclick="saveBclChoice()" aria-label="Save current choice customization">üíæ Save Choice</button>
            <button class="secondary" onclick="resetBclChoice()" aria-label="Reset choice to default implementation">üîÑ Reset to Default</button>
          </div>
          <div class="bcl-editor-default" id="bcl-editor-default" style="display: none;">
            <div class="bcl-editor-default-label">Default Behavior:</div>
            <div class="bcl-editor-default-text" id="bcl-editor-default-text"></div>
          </div>
        </div>
      </div>
      <div class="bcl-modal-footer">
        <div class="bcl-footer-info">
          <span id="bcl-customization-count">0</span> customization(s) saved
        </div>
        <div class="bcl-footer-actions">
          <button class="secondary" onclick="downloadBclDelta()" aria-label="Download BCL delta file">üì• Download BCL Delta</button>
          <button onclick="closeBclModal()" aria-label="Close and apply customizations">‚úÖ Done</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Load the Blink Engine bundle -->
  <script src="blink-engine.bundle.js"></script>
  
  <!-- Load JSZip for BCL extraction -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js" integrity="sha384-OLBgp1GsljhM2TJ+sbHjaiH9txEUvgdDTAzHv2P24donTt6/529l+9Ua0vFImLlb" crossorigin="anonymous"></script>
  
  <script>
    // ========================================================================
    // PARTY SELECTION STATE
    // ========================================================================
    let availableCharacters = [];
    let partySlots = [null, null, null, null]; // 4 slots for heroes
    let currentHeroIndex = [0, 0, 0, 0]; // Current hero index for each slot's carousel
    const MAX_PARTY_SIZE = 4;
    
    // DOM elements for party selection
    const partySelectionScreen = document.getElementById('party-selection-screen');
    const gameScreen = document.getElementById('game-screen');
    const slotsContainer = document.getElementById('slots-container');
    const selectedCountEl = document.getElementById('selected-count');
    const confirmPartyBtn = document.getElementById('confirm-party-btn');
    
    // ========================================================================
    // EXTRACT CHARACTER DATA FROM IR
    // ========================================================================
    // Character data - hero definitions for the party selection screen.
    // This function extracts hero definitions from IR.initial_state.
    //
    // SOURCE: game/bdl/heroes.bdl ‚Üí compiled into IR.initial_state
    // Heroes are entities with Team.isPlayer = true and HeroInfo component
    // ========================================================================
    function extractCharacterDataFromIR(ir) {
      if (!ir || !ir.initial_state || !ir.initial_state.entities) {
        console.error('Invalid IR structure for character extraction');
        return [];
      }
      
      // Find all entities with HeroInfo component (these are the selectable heroes)
      const heroes = ir.initial_state.entities.filter(entity => 
        entity.components.HeroInfo && entity.components.Team?.isPlayer === true
      );
      
      // Transform to the format expected by the UI
      availableCharacters = heroes.map(entity => {
        const char = entity.components.Character || {};
        const health = entity.components.Health || {};
        const mana = entity.components.Mana || {};
        const stats = entity.components.Stats || {};
        const combat = entity.components.Combat || {};
        const skills = entity.components.Skills || {};
        const heroInfo = entity.components.HeroInfo || {};
        
        return {
          id: heroInfo.id || `hero_${entity.id}`,
          name: char.name || 'Unknown Hero',
          class: char.class || 'Unknown',
          description: heroInfo.description || '',
          difficulty: heroInfo.difficulty || 'Medium',
          role: heroInfo.role || '',
          playstyle: heroInfo.playstyle || '',
          baseHealth: health.max || 100,
          baseMana: mana.max || 50,
          baseDamage: combat.damage || 10,
          baseDefense: combat.defense || 5,
          attackSpeed: combat.attackSpeed || 1.0,
          stats: {
            strength: stats.strength || 10,
            dexterity: stats.dexterity || 10,
            intelligence: stats.intelligence || 10,
            constitution: stats.constitution || 10,
            wisdom: stats.wisdom || 10
          },
          skills: [skills.skill1, skills.skill2, skills.skill3, skills.skill4].filter(s => s)
        };
      });
      
      console.info(`Extracted ${availableCharacters.length} heroes from IR.initial_state`);
      return availableCharacters;
    }
    
    // ========================================================================
    // RENDER CHARACTER SELECTION - CAROUSEL BASED
    // ========================================================================
    function renderCharacterSelection() {
      slotsContainer.innerHTML = '';
      
      // Create 4 hero slots
      for (let slotIndex = 0; slotIndex < MAX_PARTY_SIZE; slotIndex++) {
        const slot = document.createElement('div');
        slot.className = 'hero-slot';
        slot.id = `hero-slot-${slotIndex}`;
        
        // Slot header
        const slotHeader = document.createElement('div');
        slotHeader.className = 'slot-header';
        slotHeader.innerHTML = `<h3 class="slot-title">Hero Slot ${slotIndex + 1}</h3>`;
        slot.appendChild(slotHeader);
        
        // Carousel container
        const carouselContainer = document.createElement('div');
        carouselContainer.className = 'carousel-container';
        
        // Carousel controls
        const carouselControls = document.createElement('div');
        carouselControls.className = 'carousel-controls';
        
        const prevBtn = document.createElement('button');
        prevBtn.className = 'carousel-btn';
        prevBtn.innerHTML = '‚óÄ';
        prevBtn.onclick = () => navigateCarousel(slotIndex, -1);
        
        const indicator = document.createElement('div');
        indicator.className = 'carousel-indicator';
        indicator.id = `carousel-indicator-${slotIndex}`;
        
        const nextBtn = document.createElement('button');
        nextBtn.className = 'carousel-btn';
        nextBtn.innerHTML = '‚ñ∂';
        nextBtn.onclick = () => navigateCarousel(slotIndex, 1);
        
        carouselControls.appendChild(prevBtn);
        carouselControls.appendChild(indicator);
        carouselControls.appendChild(nextBtn);
        carouselContainer.appendChild(carouselControls);
        
        // Hero card display
        const heroCardDiv = document.createElement('div');
        heroCardDiv.id = `hero-card-${slotIndex}`;
        carouselContainer.appendChild(heroCardDiv);
        
        slot.appendChild(carouselContainer);
        slotsContainer.appendChild(slot);
        
        // Render the current hero for this slot
        renderHeroInSlot(slotIndex);
      }
      
      updatePartyCounter();
    }
    
    // ========================================================================
    // RENDER HERO IN SPECIFIC SLOT
    // ========================================================================
    function renderHeroInSlot(slotIndex) {
      const heroIndex = currentHeroIndex[slotIndex];
      const hero = availableCharacters[heroIndex];
      const heroCardDiv = document.getElementById(`hero-card-${slotIndex}`);
      const indicator = document.getElementById(`carousel-indicator-${slotIndex}`);
      
      if (!hero || !heroCardDiv || !indicator) return;
      
      // Check if this hero is already selected in another slot
      const isAlreadySelected = partySlots.some((selectedHero, idx) => 
        idx !== slotIndex && selectedHero && selectedHero.id === hero.id
      );
      
      // Update indicator
      indicator.textContent = `${heroIndex + 1} / ${availableCharacters.length}`;
      
      // Difficulty color mapping
      const difficultyColor = {
        'Easy': '#9ca873',
        'Medium': '#c9956b',
        'Hard': '#a85e52'
      }[hero.difficulty] || '#8a7a68';
      
      // Create hero card HTML
      heroCardDiv.className = 'hero-card';
      if (isAlreadySelected) {
        heroCardDiv.classList.add('unavailable');
      }
      
      heroCardDiv.innerHTML = `
        <div class="character-header">
          <div class="character-title">
            <h3>${hero.name}</h3>
            <div class="character-class">${hero.class}</div>
          </div>
        </div>
        
        <div class="character-description">${hero.description}</div>
        
        <div style="margin-bottom: 8px;">
          <span class="character-role">${hero.role}</span>
          <span class="character-role" style="background: rgba(${difficultyColor === '#9ca873' ? '156, 168, 115' : difficultyColor === '#c9956b' ? '201, 149, 107' : '168, 94, 82'}, 0.2); color: ${difficultyColor};">${hero.difficulty}</span>
        </div>
        
        <div class="character-stats-preview">
          <div class="stat-preview">
            <span>‚ù§Ô∏è Health:</span>
            <span class="stat-preview-value">${hero.baseHealth}</span>
          </div>
          <div class="stat-preview">
            <span>‚öîÔ∏è Damage:</span>
            <span class="stat-preview-value">${hero.baseDamage}</span>
          </div>
          <div class="stat-preview">
            <span>üíß Mana:</span>
            <span class="stat-preview-value">${hero.baseMana}</span>
          </div>
          <div class="stat-preview">
            <span>üõ°Ô∏è Defense:</span>
            <span class="stat-preview-value">${hero.baseDefense}</span>
          </div>
        </div>
        
        <button class="hero-customize-btn ${hasHeroCustomizations(hero.id) ? 'has-customizations' : ''}" 
                data-hero-id="${escapeHtml(hero.id)}"
                data-hero-name="${escapeHtml(hero.name)}"
                data-hero-class="${escapeHtml(hero.class)}"
                aria-label="${hasHeroCustomizations(hero.id) ? 'Edit Strategy for ' + escapeHtml(hero.name) : 'Customize Strategy for ' + escapeHtml(hero.name)}">
          ${hasHeroCustomizations(hero.id) ? '‚úèÔ∏è Edit Strategy' : 'üéØ Customize Strategy'}
        </button>
      `;
      
      // Add event listener for customize button
      const customizeBtn = heroCardDiv.querySelector('.hero-customize-btn');
      if (customizeBtn) {
        customizeBtn.addEventListener('click', (e) => {
          const btn = e.currentTarget;
          openBclModal(btn.dataset.heroId, btn.dataset.heroName, btn.dataset.heroClass);
        });
      }
      
      // Update the selection state for this slot
      // Only set as selected if not already selected elsewhere
      if (!isAlreadySelected) {
        partySlots[slotIndex] = hero;
      } else {
        // If the currently displayed hero is already selected elsewhere, clear this slot
        if (partySlots[slotIndex] && partySlots[slotIndex].id === hero.id) {
          partySlots[slotIndex] = null;
        }
      }
    }
    
    // ========================================================================
    // NAVIGATE CAROUSEL
    // ========================================================================
    function navigateCarousel(slotIndex, direction) {
      // Update the current index
      currentHeroIndex[slotIndex] = (currentHeroIndex[slotIndex] + direction + availableCharacters.length) % availableCharacters.length;
      
      // Re-render this slot
      renderHeroInSlot(slotIndex);
      
      updatePartyCounter();
    }
    
    // ========================================================================
    // UPDATE PARTY COUNTER
    // ========================================================================
    function updatePartyCounter() {
      const selectedCount = partySlots.filter(hero => hero !== null).length;
      selectedCountEl.textContent = selectedCount;
      confirmPartyBtn.disabled = selectedCount !== MAX_PARTY_SIZE;
    }
    
    // ========================================================================
    // ========================================================================
    // BCL CUSTOMIZATION SYSTEM
    // ========================================================================
    // BCL (Blink Choice Language) allows players to customize AI strategy.
    //
    // CURRENT STATE:
    //   - Choice points metadata should come from IR.choice_points
    //   - Player customizations stored in localStorage as text
    //   - Can download customizations as .bcl delta file
    //   - Customizations are NOT compiled/executed (cosmetic only)
    //
    // FUTURE STATE (with browser-based BCL compiler):
    //   1. Choice points loaded from IR.choice_points (with signatures, docstrings)
    //   2. Player edits BCL code in browser editor
    //   3. Browser-based WASM compiler compiles BCL to choice_functions
    //   4. Delta IR merged with base IR for runtime execution
    //   5. Custom strategy actually affects gameplay
    //
    // For browser-based BRL/BDL editing (future release):
    //   - Same WASM compiler can handle BRL/BDL edits
    //   - Delta compilation: merge changes with base IR
    //   - Hot reload without page refresh
    // ========================================================================
    const BCL_STORAGE_KEY = 'blink_bcl_customizations';
    let currentBclHeroId = null;
    let currentBclChoice = null;
    let choicePointsData = [];
    
    // ========================================================================
    // LOAD CHOICE POINTS (From IR.choice_points)
    // ========================================================================
    // Choice points are metadata about customizable player decisions.
    // They define the signature and behavior of BCL choice functions.
    //
    // SOURCE: BCL files (*.bcl) ‚Üí IR.choice_points (when compiler supports it)
    //
    // FUTURE: Compiler will extract choice point metadata from BCL:
    //   - id: Unique identifier
    //   - name: Human-readable name
    //   - signature: Function signature for editor
    //   - docstring: Documentation for player
    //   - category: Grouping (targeting, combat, strategy, etc.)
    //   - applicableClasses: Which hero classes can use this choice
    //   - defaultBehavior: Description of default behavior
    // ========================================================================
    async function loadChoicePoints() {
      if (classicRpgIR && classicRpgIR.choice_points) {
        choicePointsData = classicRpgIR.choice_points;
        console.info(`Loaded ${choicePointsData.length} choice points from IR`);
      } else {
        console.warn('No choice points found in IR (not yet implemented in compiler)');
        choicePointsData = [];
        // TODO: Once compiler adds choice_points to IR, this will work automatically
      }
    }
    
    // HTML escape helper to prevent XSS
    function escapeHtml(str) {
      if (str === null || str === undefined) return '';
      const div = document.createElement('div');
      div.textContent = str;
      return div.innerHTML;
    }
    
    // Get customizations from localStorage
    function getBclCustomizations() {
      try {
        const stored = localStorage.getItem(BCL_STORAGE_KEY);
        return stored ? JSON.parse(stored) : {};
      } catch (e) {
        console.error('Failed to load BCL customizations:', e);
        return {};
      }
    }
    
    // Save customizations to localStorage
    function saveBclCustomizations(customizations) {
      try {
        localStorage.setItem(BCL_STORAGE_KEY, JSON.stringify(customizations));
      } catch (e) {
        console.error('Failed to save BCL customizations:', e);
      }
    }
    
    // Check if a hero has any customizations
    function hasHeroCustomizations(heroId) {
      const customizations = getBclCustomizations();
      return customizations[heroId] && Object.keys(customizations[heroId]).length > 0;
    }
    
    // Get customization count for a hero
    function getHeroCustomizationCount(heroId) {
      const customizations = getBclCustomizations();
      return customizations[heroId] ? Object.keys(customizations[heroId]).length : 0;
    }
    
    // Open the BCL customization modal
    function openBclModal(heroId, heroName, heroClass) {
      currentBclHeroId = heroId;
      currentBclChoice = null;
      
      // Update modal title
      document.getElementById('bcl-modal-hero-name').textContent = heroName;
      
      // Populate choices list
      const choicesContainer = document.getElementById('bcl-choices-container');
      const customizations = getBclCustomizations();
      const heroCustomizations = customizations[heroId] || {};
      
      // Filter choice points that apply to this hero's class
      const applicableChoices = choicePointsData.filter(cp => {
        if (!cp.applicableClasses) return true;
        return cp.applicableClasses.includes(heroClass);
      });
      
      choicesContainer.innerHTML = applicableChoices.map(cp => {
        const isCustomized = heroCustomizations[cp.id] !== undefined;
        return `
          <div class="choice-item ${isCustomized ? 'customized' : ''}" 
               data-choice-id="${escapeHtml(cp.id)}"
               role="button"
               tabindex="0"
               aria-label="${escapeHtml(cp.name)}: ${escapeHtml(cp.docstring)}">
            <div class="choice-item-name">${escapeHtml(cp.name)}</div>
            <span class="choice-item-category">${escapeHtml(cp.category)}</span>
            <div class="choice-item-description">${escapeHtml(cp.docstring)}</div>
          </div>
        `;
      }).join('');
      
      // Add event listeners for choice items (event delegation)
      choicesContainer.querySelectorAll('.choice-item').forEach(item => {
        item.addEventListener('click', () => selectBclChoice(item.dataset.choiceId));
        item.addEventListener('keydown', (e) => {
          if (e.key === 'Enter' || e.key === ' ') {
            e.preventDefault();
            selectBclChoice(item.dataset.choiceId);
          }
        });
      });
      
      // Update customization count
      updateBclCustomizationCount();
      
      // Reset editor
      resetBclEditor();
      
      // Show modal
      document.getElementById('bcl-modal-overlay').classList.add('active');
    }
    
    // Close the BCL customization modal
    function closeBclModal() {
      document.getElementById('bcl-modal-overlay').classList.remove('active');
      currentBclHeroId = null;
      currentBclChoice = null;
      
      // Re-render all hero slots to update customize buttons
      for (let i = 0; i < MAX_PARTY_SIZE; i++) {
        renderHeroInSlot(i);
      }
    }
    
    // Select a choice point for editing
    function selectBclChoice(choiceId) {
      currentBclChoice = choiceId;
      
      // Update selection UI
      document.querySelectorAll('.choice-item').forEach(item => {
        item.classList.remove('selected');
        if (item.dataset.choiceId === choiceId) {
          item.classList.add('selected');
        }
      });
      
      // Get choice point data
      const choicePoint = choicePointsData.find(cp => cp.id === choiceId);
      if (!choicePoint) return;
      
      // Update editor header
      document.getElementById('bcl-editor-title').textContent = `Edit: ${choicePoint.name}`;
      
      const signatureEl = document.getElementById('bcl-editor-signature');
      signatureEl.textContent = choicePoint.signature;
      signatureEl.style.display = 'block';
      
      const docstringEl = document.getElementById('bcl-editor-docstring');
      docstringEl.textContent = choicePoint.docstring;
      docstringEl.style.display = 'block';
      
      const defaultEl = document.getElementById('bcl-editor-default');
      const defaultTextEl = document.getElementById('bcl-editor-default-text');
      defaultTextEl.textContent = choicePoint.defaultBehavior || 'Uses engine default';
      defaultEl.style.display = 'block';
      
      // Load existing customization or default template
      const customizations = getBclCustomizations();
      const heroCustomizations = customizations[currentBclHeroId] || {};
      const existingCode = heroCustomizations[choiceId];
      
      const textarea = document.getElementById('bcl-editor-textarea');
      if (existingCode) {
        textarea.value = existingCode;
      } else {
        // Provide a template based on the choice point
        textarea.value = generateBclTemplate(choicePoint);
      }
    }
    
    // Generate a BCL template for a choice point
    function generateBclTemplate(choicePoint) {
      const templates = {
        'select_attack_target': `// Customize target selection
// Return the id of the enemy to attack

choice fn select_attack_target(character: Character, enemies: list): id {
    // Example: Target enemy with lowest health
    let target = enemies[0]
    for enemy in enemies {
        if enemy.Health.current < target.Health.current {
            target = enemy
        }
    }
    return target.id
}`,
        'select_combat_skill': `// Customize skill selection in combat
// Return the name of the skill to use

choice fn select_combat_skill(character: Character & Skills & Health & Mana, allies: list, enemies: list): string {
    let hp_pct = character.Health.current / character.Health.max
    let mana_pct = character.Mana.current / character.Mana.max
    
    // Example: Use defensive skill if low health
    if hp_pct < 0.3 {
        return "defensive_stance"
    }
    
    // Default to basic attack
    return "basic_attack"
}`,
        'select_skill_on_levelup': `// Customize skill progression on level up
// Return the name of the skill to learn

choice fn select_skill_on_levelup(character: Character & Skills, currentLevel: number): string {
    // Example: Learn power_strike at level 2
    if currentLevel == 2 {
        return "power_strike"
    }
    
    return "basic_attack"
}`,
        'select_heal_target': `// Customize heal target selection
// Return the id of the ally to heal, or null if no one needs healing

choice fn select_heal_target(character: Character, allies: list): id? {
    let critical_threshold = 0.3
    
    // Find critically wounded ally
    for ally in allies {
        let hp_pct = ally.Health.current / ally.Health.max
        if hp_pct < critical_threshold {
            return ally.id
        }
    }
    
    return null
}`,
        'should_flee_from_battle': `// Customize flee decision
// Return true to flee, false to continue fighting

choice fn should_flee_from_battle(party: list, enemies: list, runStats: RunStats): boolean {
    // Calculate average party health
    let total_health = 0.0
    let total_max_health = 0.0
    
    for hero in party {
        total_health += hero.Health.current
        total_max_health += hero.Health.max
    }
    
    let avg_health = total_health / total_max_health
    
    // Flee if party health is below 30%
    if avg_health < 0.3 {
        return true
    }
    
    return false
}`
      };
      
      return templates[choicePoint.id] || `// Customize ${choicePoint.name}\n\n${choicePoint.signature} {\n    // Your code here\n}`;
    }
    
    // Reset the BCL editor to empty state
    function resetBclEditor() {
      document.getElementById('bcl-editor-title').textContent = 'Select a choice to customize';
      document.getElementById('bcl-editor-signature').style.display = 'none';
      document.getElementById('bcl-editor-docstring').style.display = 'none';
      document.getElementById('bcl-editor-default').style.display = 'none';
      document.getElementById('bcl-editor-textarea').value = '';
      
      document.querySelectorAll('.choice-item').forEach(item => {
        item.classList.remove('selected');
      });
    }
    
    // Save the current choice customization
    function saveBclChoice() {
      if (!currentBclHeroId || !currentBclChoice) {
        alert('Please select a choice to save.');
        return;
      }
      
      const code = document.getElementById('bcl-editor-textarea').value.trim();
      if (!code) {
        alert('Please enter some code before saving.');
        return;
      }
      
      const customizations = getBclCustomizations();
      if (!customizations[currentBclHeroId]) {
        customizations[currentBclHeroId] = {};
      }
      customizations[currentBclHeroId][currentBclChoice] = code;
      
      saveBclCustomizations(customizations);
      
      // Update UI
      updateBclCustomizationCount();
      updateChoiceItemCustomized(currentBclChoice, true);
      
      alert('Choice saved successfully!');
    }
    
    // Reset a choice to default (remove customization)
    function resetBclChoice() {
      if (!currentBclHeroId || !currentBclChoice) {
        alert('Please select a choice to reset.');
        return;
      }
      
      if (!confirm('Reset this choice to default? Your customization will be removed.')) {
        return;
      }
      
      const customizations = getBclCustomizations();
      if (customizations[currentBclHeroId]) {
        delete customizations[currentBclHeroId][currentBclChoice];
        
        // Clean up empty hero entry
        if (Object.keys(customizations[currentBclHeroId]).length === 0) {
          delete customizations[currentBclHeroId];
        }
        
        saveBclCustomizations(customizations);
      }
      
      // Update UI
      updateBclCustomizationCount();
      updateChoiceItemCustomized(currentBclChoice, false);
      
      // Reset editor to template
      const choicePoint = choicePointsData.find(cp => cp.id === currentBclChoice);
      if (choicePoint) {
        document.getElementById('bcl-editor-textarea').value = generateBclTemplate(choicePoint);
      }
    }
    
    // Update the customization count display
    function updateBclCustomizationCount() {
      const count = getHeroCustomizationCount(currentBclHeroId);
      document.getElementById('bcl-customization-count').textContent = count;
    }
    
    // Update a choice item's customized state
    function updateChoiceItemCustomized(choiceId, isCustomized) {
      const item = document.querySelector(`.choice-item[data-choice-id="${choiceId}"]`);
      if (item) {
        if (isCustomized) {
          item.classList.add('customized');
        } else {
          item.classList.remove('customized');
        }
      }
    }
    
    // Download BCL delta file for the current hero
    function downloadBclDelta() {
      if (!currentBclHeroId) {
        alert('No hero selected.');
        return;
      }
      
      const customizations = getBclCustomizations();
      const heroCustomizations = customizations[currentBclHeroId];
      
      if (!heroCustomizations || Object.keys(heroCustomizations).length === 0) {
        alert('No customizations to download for this hero.');
        return;
      }
      
      // Build BCL delta content
      let bclContent = `// BCL Delta for ${currentBclHeroId}\n`;
      bclContent += `// Generated: ${new Date().toISOString()}\n`;
      bclContent += `// Contains ${Object.keys(heroCustomizations).length} customized choice(s)\n\n`;
      bclContent += `module ${currentBclHeroId}_customizations\n\n`;
      
      for (const [choiceId, code] of Object.entries(heroCustomizations)) {
        const choicePoint = choicePointsData.find(cp => cp.id === choiceId);
        bclContent += `// === ${choicePoint?.name || choiceId} ===\n`;
        bclContent += code + '\n\n';
      }
      
      // Create and download file
      const blob = new Blob([bclContent], { type: 'text/plain' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `${currentBclHeroId}-strategy.bcl`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }
    
    // Initialize BCL system when page loads
    async function initBclSystem() {
      await loadChoicePoints();
    }
    
    // ========================================================================
    // START GAME WITH SELECTED PARTY
    // ========================================================================
    confirmPartyBtn.addEventListener('click', () => {
      const selectedCharacters = partySlots.filter(hero => hero !== null);
      if (selectedCharacters.length === MAX_PARTY_SIZE) {
        partySelectionScreen.style.display = 'none';
        gameScreen.classList.add('active');
        initGameWithParty();
      }
    });
    
    // ========================================================================
    // GAME STATE
    // ========================================================================
    let game = null;
    let currentIR = null;
    let loadedBCLFiles = [];
    let playerCharacters = {};
    let enemyCharacters = {};
    let gameState = { wave: 1, enemiesDefeated: 0, playerDeaths: 0, victory: false, gameOver: false };
    let nextEnemyId = 100; // Start enemy IDs from 100 to avoid conflicts
    let lastLoggedKills = 0; // Track kills for summary logging
    let updateCounter = 0; // Counter for batched UI updates
    
    // ========================================================================
    // RUN TRACKING STATE
    // ========================================================================
    const RETREAT_TIME_PENALTY = 10; // X seconds penalty for fleeing
    const DEATH_TIME_MULTIPLIER = 5; // N times X for death penalty (50 seconds)
    const FLEE_COOLDOWN = 5; // Seconds cooldown between flee attempts
    
    let runState = {
      runId: null,
      startTime: null,
      simulationTime: 0,
      totalTime: 0, // Simulation time + penalties
      retreatCount: 0,
      retreatPenalty: 0,
      deathPenalty: 0,
      lastFleeTime: -999, // Last time flee was used
      canFlee: true
    };
    
    // DOM elements for run tracking
    const totalTimeEl = document.getElementById('total-time');
    const retreatCountEl = document.getElementById('retreat-count');
    const retreatPenaltyEl = document.getElementById('retreat-penalty');
    const deathPenaltyEl = document.getElementById('death-penalty');
    const totalPenaltiesEl = document.getElementById('total-penalties');
    const fleeBtn = document.getElementById('flee-btn');
    
    // DOM elements
    const irFileInput = document.getElementById('ir-file');
    const bclFileInput = document.getElementById('bcl-file');
    const irStatus = document.getElementById('ir-status');
    const bclStatus = document.getElementById('bcl-status');
    const bclInfo = document.getElementById('bcl-info');
    const bclFileList = document.getElementById('bcl-file-list');
    const startBtn = document.getElementById('start-btn');
    const pauseBtn = document.getElementById('pause-btn');
    const resetBtn = document.getElementById('reset-btn');
    const logContainer = document.getElementById('log-container');
    const speedSlider = document.getElementById('speed-slider');
    const speedValue = document.getElementById('speed-value');
    const gameTimeEl = document.getElementById('game-time');
    const currentWaveEl = document.getElementById('current-wave');
    const enemiesDefeatedEl = document.getElementById('enemies-defeated');
    const playerDeathsEl = document.getElementById('player-deaths');
    const gameStatusEl = document.getElementById('game-status');
    const gameBanner = document.getElementById('game-banner');
    const bannerText = document.getElementById('banner-text');
    const playerPartyEl = document.getElementById('player-party');
    const enemyPartyEl = document.getElementById('enemy-party');
    
    // Classic RPG IR - will be loaded from file
    let classicRpgIR = null;
    
    // Enemy templates - loaded from IR.initial_state
    let enemyTemplates = [];
    
    // ========================================================================
    // EXTRACT ENEMY DATA FROM IR
    // ========================================================================
    // Enemy templates - creature definitions used for spawning enemies.
    // This function extracts enemy templates from IR.initial_state.
    //
    // SOURCE: game/bdl/enemies.bdl ‚Üí compiled into IR.initial_state
    // Enemies are entities with Enemy component and Team.isPlayer = false
    // ========================================================================
    function extractEnemyDataFromIR(ir) {
      if (!ir || !ir.initial_state || !ir.initial_state.entities) {
        console.error('Invalid IR structure for enemy extraction');
        return [];
      }
      
      // Find all entities with Enemy component (these are the enemy templates)
      const enemies = ir.initial_state.entities.filter(entity => 
        entity.components.Enemy && entity.components.Team?.isPlayer === false
      );
      
      // Transform to the format expected by the spawn logic
      enemyTemplates = enemies.map(entity => {
        const char = entity.components.Character || {};
        const health = entity.components.Health || {};
        const combat = entity.components.Combat || {};
        const enemy = entity.components.Enemy || {};
        
        return {
          name: char.name || 'Unknown Enemy',
          tier: enemy.tier || 1,
          health: health.max || 50,
          damage: combat.damage || 10,
          speed: combat.attackSpeed || 1.0,
          exp: enemy.expReward || 25,
          boss: enemy.isBoss || false
        };
      });
      
      console.info(`Extracted ${enemyTemplates.length} enemy templates from IR.initial_state`);
      return enemyTemplates;
    }
    
    // Embedded classic-rpg.ir.json data
    
    
    // Load IR from file (fail-fast; no embedded fallback)
    async function loadDefaultIR() {
      // Try GitHub Pages path first, then local dev path
      const paths = ['data/classic-rpg.ir.json', '../ir/classic-rpg.ir.json'];
      
      for (const path of paths) {
        try {
          console.debug(`Attempting to load IR from: ${path}`);
          const response = await fetch(path);
          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
          }
          classicRpgIR = await response.json();
          console.info(`Successfully loaded IR from ${path}`);
          irStatus.textContent = `Loaded from ${path}`;
          irStatus.className = 'file-status loaded';
          return; // Success, exit function
        } catch (error) {
          console.warn(`Failed to load from ${path}:`, error.message);
          // Try next path
        }
      }
      
      // If we get here, all paths failed
      const errorMsg = 'Failed to load classic-rpg.ir.json. Please check that the file is deployed correctly.';
      console.error('ERROR: Failed to load IR from all paths:', paths);
      irStatus.textContent = errorMsg;
      irStatus.className = 'file-status error';
      throw new Error(errorMsg);
    }

    
    // File upload handlers
    irFileInput.addEventListener('change', async (e) => {
      const file = e.target.files[0];
      if (!file) return;
      
      try {
        const text = await file.text();
        currentIR = JSON.parse(text);
        irStatus.textContent = `Loaded: ${file.name}`;
        irStatus.className = 'file-status loaded';
        addLogEntry('system', `Loaded game rules from ${file.name}`);
        resetGame();
      } catch (err) {
        irStatus.textContent = `Error: ${err.message}`;
        irStatus.className = 'file-status error';
      }
    });
    
    bclFileInput.addEventListener('change', async (e) => {
      const file = e.target.files[0];
      if (!file) return;
      
      try {
        const zip = await JSZip.loadAsync(file);
        loadedBCLFiles = [];
        bclFileList.innerHTML = '';
        
        for (const [filename, zipEntry] of Object.entries(zip.files)) {
          if (filename.endsWith('.bcl') && !zipEntry.dir) {
            const content = await zipEntry.async('string');
            loadedBCLFiles.push({ name: filename, content });
            
            const fileItem = document.createElement('span');
            fileItem.className = 'bcl-file-item';
            fileItem.textContent = filename;
            bclFileList.appendChild(fileItem);
          }
        }
        
        if (loadedBCLFiles.length > 0) {
          bclStatus.textContent = `Loaded ${loadedBCLFiles.length} BCL files`;
          bclStatus.className = 'file-status loaded';
          bclInfo.style.display = 'block';
          addLogEntry('system', `Loaded ${loadedBCLFiles.length} BCL strategy files`);
        } else {
          bclStatus.textContent = 'No BCL files found in ZIP';
          bclStatus.className = 'file-status error';
          bclInfo.style.display = 'none';
        }
      } catch (err) {
        bclStatus.textContent = `Error: ${err.message}`;
        bclStatus.className = 'file-status error';
      }
    });
    
    // Enemy templates - loaded from enemies.json file (no longer hardcoded)
    
    // Spawn a new enemy
    function spawnEnemy() {
      // Select enemy based on how many have been defeated
      const kills = gameState.enemiesDefeated;
      let template;
      
      // Every 100 kills, spawn a boss
      if (kills > 0 && kills % 100 === 0) {
        template = enemyTemplates[7]; // Dragon boss
      } else {
        // Select based on progression
        const tier = Math.min(6, Math.floor(kills / 50) + 1);
        const candidates = enemyTemplates.filter(t => !t.boss && t.tier <= tier);
        template = candidates[Math.floor(Math.random() * candidates.length)];
      }
      
      const enemyId = nextEnemyId++;
      game.createEntity(enemyId);
      
      // Randomly target one of the 4 heroes
      const targetHero = Math.floor(Math.random() * 4);
      
      game.addComponent(enemyId, 'Character', {
        name: template.name + (template.boss ? '' : ' #' + (kills + 1)),
        class: template.boss ? 'Boss' : 'Monster',
        level: Math.max(1, Math.floor(kills / 20) + 1),
      });
      
      game.addComponent(enemyId, 'Health', {
        current: template.health * (1 + kills / 200), // Scale with progression
        max: template.health * (1 + kills / 200),
      });
      
      game.addComponent(enemyId, 'Mana', {
        current: 0,
        max: 0,
      });
      
      game.addComponent(enemyId, 'Combat', {
        damage: template.damage * (1 + kills / 300),
        defense: 2 + Math.floor(kills / 50),
        attackSpeed: template.speed,
      });
      
      game.addComponent(enemyId, 'Target', {
        entity: targetHero,
      });
      
      game.addComponent(enemyId, 'Team', {
        id: 'enemy',
        isPlayer: false,
      });
      
      game.addComponent(enemyId, 'Enemy', {
        tier: template.tier,
        isBoss: template.boss || false,
        expReward: template.exp,
      });
      
      game.addComponent(enemyId, 'Buffs', {
        damageBonus: 0,
      });
      
      // Schedule first attack
      game.scheduleEvent('DoAttack', 0.1, { source: enemyId });
      
      return enemyId;
    }
    
    // Spawn multiple enemies at start
    function spawnInitialEnemies(count) {
      const spawnedIds = [];
      for (let i = 0; i < count; i++) {
        spawnedIds.push(spawnEnemy());
      }
      
      // After spawning enemies, assign hero targets
      // Each hero targets a random enemy
      for (let heroId = 0; heroId <= 3; heroId++) {
        const randomEnemy = spawnedIds[Math.floor(Math.random() * spawnedIds.length)];
        game.setComponentField(heroId, 'Target', 'entity', randomEnemy);
      }
    }
    
    // Initialize game
    // ========================================================================
    // INIT GAME WITH SELECTED PARTY
    // ========================================================================
    async function initGameWithParty() {
      // Get selected characters from party slots
      const selectedCharacters = partySlots.filter(hero => hero !== null);
      
      // Load default IR if not already loaded
      if (!classicRpgIR && !currentIR) {
        await loadDefaultIR();
      }
      
      const ir = currentIR || classicRpgIR;
      
      if (!ir) {
        console.error('Failed to load IR');
        addLogEntry('system', '‚ùå ERROR: Failed to load game rules. Please refresh the page.');
        gameStatusEl.textContent = 'Error';
        gameStatusEl.style.color = '#a85e52';
        return;
      }
      
      if (enemyTemplates.length === 0) {
        console.error('Failed to load enemy templates');
        addLogEntry('system', '‚ùå ERROR: Failed to load enemy data. Please refresh the page.');
        gameStatusEl.textContent = 'Error';
        gameStatusEl.style.color = '#a85e52';
        return;
      }
      
      // Modify IR to use selected characters
      const modifiedIR = JSON.parse(JSON.stringify(ir));
      
      // Update initial state with selected characters
      modifiedIR.initial_state.entities = modifiedIR.initial_state.entities.filter(e => !e.components.Team || !e.components.Team.isPlayer);
      
      // Add selected characters as player entities
      selectedCharacters.forEach((char, index) => {
        const entityId = index;
        modifiedIR.initial_state.entities.unshift({
          id: entityId,
          components: {
            Character: {
              name: char.name,
              class: char.class,
              level: 1,
              experience: 0,
              experienceToLevel: 100
            },
            Health: {
              current: char.baseHealth,
              max: char.baseHealth
            },
            Mana: {
              current: char.baseMana,
              max: char.baseMana
            },
            Stats: char.stats,
            Combat: {
              damage: char.baseDamage,
              defense: char.baseDefense,
              attackSpeed: char.attackSpeed,
              critChance: 0.05,
              critMultiplier: 1.5
            },
            Target: {
              entity: 4 + index // Will be updated when enemies spawn
            },
            Team: {
              id: 'player',
              isPlayer: true
            },
            Skills: {
              skill1: char.skills ? char.skills[0] : '',
              skill2: '',
              skill3: '',
              skill4: '',
              skillPoints: 0
            },
            Buffs: {
              damageBonus: 0,
              defenseBonus: 0,
              hasteBonus: 0,
              shieldAmount: 0,
              regenAmount: 0
            },
            SkillCooldown: {
              skill1Cooldown: 0,
              skill2Cooldown: 0,
              skill3Cooldown: 0,
              skill4Cooldown: 0
            },
            ChoiceContext: {
              pendingChoice: '',
              options: '',
              chosen: ''
            }
          }
        });
      });
      
      game = BlinkEngine.BlinkGame.createSync({
        debug: false,
        timeScale: parseFloat(speedSlider.value),
        discreteTimeStep: 0.01,
        maxEventsPerFrame: 1000
      });
      
      game.loadRulesFromObject(modifiedIR);
      
      // Initialize character data
      updateCharacterData();
      
      // Initialize run tracking
      initializeRun();
      
      // Subscribe to tracker events
      game.onTracker((output) => {
        handleTrackerOutput(output);
      });
      
      // Subscribe to simulation events
      game.onSimulation((event) => {
        handleSimulationEvent(event);
      });
      
      // Schedule initial attack events for selected heroes
      for (let i = 0; i < selectedCharacters.length; i++) {
        const health = game.getComponent(i, 'Health');
        if (health && health.current > 0) {
          game.scheduleEvent('DoAttack', i * 0.1, { source: i });
        }
      }
      
      // Spawn initial set of enemies
      spawnInitialEnemies(5);
      
      renderParties();
      refreshLeaderboard();
      addLogEntry('system', `‚öîÔ∏è ${selectedCharacters.map(c => c.name).join(', ')} are ready for battle!`);
      addLogEntry('system', 'Press Start to begin the adventure!');
    }
    
    async function initGame() {
      // Load default IR if not already loaded
      if (!classicRpgIR && !currentIR) {
        await loadDefaultIR();
      }
      
      const ir = currentIR || classicRpgIR;
      
      if (!ir) {
        console.error('Failed to load IR');
        addLogEntry('system', '‚ùå ERROR: Failed to load game rules. Please refresh the page.');
        gameStatusEl.textContent = 'Error';
        gameStatusEl.style.color = '#f87171';
        return;
      }
      
      if (enemyTemplates.length === 0) {
        console.error('Failed to load enemy templates');
        addLogEntry('system', '‚ùå ERROR: Failed to load enemy data. Please refresh the page.');
        gameStatusEl.textContent = 'Error';
        gameStatusEl.style.color = '#f87171';
        return;
      }
      
      game = BlinkEngine.BlinkGame.createSync({
        debug: false,
        timeScale: parseFloat(speedSlider.value),
        discreteTimeStep: 0.01, // 1/100th of a second time steps
        maxEventsPerFrame: 1000 // Process more events per frame for speed
      });
      
      game.loadRulesFromObject(ir);
      
      // Initialize character data
      updateCharacterData();
      
      // Subscribe to tracker events
      game.onTracker((output) => {
        handleTrackerOutput(output);
      });
      
      // Subscribe to simulation events
      game.onSimulation((event) => {
        handleSimulationEvent(event);
      });
      
      // Subscribe to debug events for dev mode
      game.onDebug((event) => {
        if (devModeEnabled) {
          handleDebugEvent(event);
        }
      });
      
      // Set dev mode if already enabled
      if (devModeEnabled) {
        game.setDevMode(true);
      }
      
      // Schedule initial attack events for heroes (0-3)
      for (let i = 0; i <= 3; i++) {
        const health = game.getComponent(i, 'Health');
        if (health && health.current > 0) {
          game.scheduleEvent('DoAttack', i * 0.1, { source: i });
        }
      }
      
      // Spawn initial set of enemies (5 enemies to start)
      spawnInitialEnemies(5);
      
      renderParties();
      addLogEntry('system', 'Battle initialized! Ready for 1000 fights. Press Start to begin.');
    }
    
    function updateCharacterData() {
      playerCharacters = {};
      enemyCharacters = {};
      
      // Query all entities with Team component to find heroes and enemies
      const teamEntities = game.query('Team', 'Character', 'Health');
      
      for (const entityId of teamEntities) {
        const team = game.getComponent(entityId, 'Team');
        const char = game.getComponent(entityId, 'Character');
        const health = game.getComponent(entityId, 'Health');
        
        if (!char || !health || !team) continue;
        
        if (team.isPlayer) {
          // It's a player character
          const mana = game.getComponent(entityId, 'Mana');
          const combat = game.getComponent(entityId, 'Combat');
          const skills = game.getComponent(entityId, 'Skills');
          
          playerCharacters[entityId] = {
            id: entityId,
            name: char.name,
            class: char.class,
            level: char.level,
            experience: char.experience,
            experienceToLevel: char.experienceToLevel,
            health: health.current,
            maxHealth: health.max,
            mana: mana?.current || 0,
            maxMana: mana?.max || 0,
            damage: combat?.damage || 0,
            defense: combat?.defense || 0,
            attackSpeed: combat?.attackSpeed || 1,
            skills: skills ? [skills.skill1, skills.skill2].filter(s => s) : [],
            skillPoints: skills?.skillPoints || 0
          };
        } else {
          // It's an enemy
          const combat = game.getComponent(entityId, 'Combat');
          const enemy = game.getComponent(entityId, 'Enemy');
          
          enemyCharacters[entityId] = {
            id: entityId,
            name: char.name,
            class: char.class,
            level: char.level,
            health: health.current,
            maxHealth: health.max,
            damage: combat?.damage || 0,
            defense: combat?.defense || 0,
            attackSpeed: combat?.attackSpeed || 1,
            tier: enemy?.tier || 1,
            isBoss: enemy?.isBoss || false
          };
        }
      }
      
      // Update game state
      const gs = game.getComponent(99, 'GameState');
      if (gs) {
        gameState.wave = gs.currentWave;
        gameState.enemiesDefeated = gs.enemiesDefeated;
        gameState.playerDeaths = gs.playerDeaths || 0;
        gameState.victory = gs.victory;
        gameState.gameOver = gs.gameOver;
      }
    }
    
    function renderCharacterCard(char, isPlayer) {
      const isDead = char.health <= 0;
      const healthPct = Math.max(0, (char.health / char.maxHealth) * 100);
      const manaPct = char.maxMana > 0 ? Math.max(0, (char.mana / char.maxMana) * 100) : 0;
      const expPct = isPlayer ? Math.max(0, (char.experience / char.experienceToLevel) * 100) : 0;
      
      let skillsHtml = '';
      if (isPlayer && char.skills && char.skills.length > 0) {
        skillsHtml = '<div class="skills-row">' + 
          char.skills.map(s => `<span class="skill-badge">${s}</span>`).join('') +
          '</div>';
      }
      
      const classEmoji = {
        'Warrior': '‚öîÔ∏è', 'Mage': 'üîÆ', 'Rogue': 'üó°Ô∏è', 'Cleric': '‚ú®',
        'Monster': 'üëπ', 'Boss': 'üêâ'
      };
      
      return `
        <div class="character-card ${isDead ? 'dead' : ''}" id="char-${char.id}">
          <div class="char-header" onclick="toggleAccordion('char-details-${char.id}')">
            <div>
              <span class="char-name">${classEmoji[char.class] || 'üë§'} ${char.name}</span>
              <div class="char-class">${char.class}${char.isBoss ? ' (BOSS)' : ''}</div>
            </div>
            <div style="display: flex; gap: 8px; align-items: center;">
              <span class="char-level">Lv ${char.level}</span>
              <span class="accordion-toggle" id="char-details-${char.id}-toggle">‚ñº</span>
            </div>
          </div>
          
          <div class="char-summary">
            <div class="stat-bar">
              <div class="stat-bar-header">
                <span>‚ù§Ô∏è HP</span>
                <span>${Math.max(0, Math.round(char.health))} / ${char.maxHealth}</span>
              </div>
              <div class="bar-container">
                <div class="bar-fill health-bar" style="width: ${healthPct}%"></div>
              </div>
            </div>
          </div>
          
          <div class="char-details" id="char-details-${char.id}">
            ${char.maxMana > 0 ? `
            <div class="stat-bar">
              <div class="stat-bar-header">
                <span>üíß Mana</span>
                <span>${Math.max(0, Math.round(char.mana))} / ${char.maxMana}</span>
              </div>
              <div class="bar-container">
                <div class="bar-fill mana-bar" style="width: ${manaPct}%"></div>
              </div>
            </div>
            ` : ''}
            
            ${isPlayer ? `
            <div class="stat-bar">
              <div class="stat-bar-header">
                <span>‚≠ê XP</span>
                <span>${Math.round(char.experience)} / ${Math.round(char.experienceToLevel)}</span>
              </div>
              <div class="bar-container">
                <div class="bar-fill exp-bar" style="width: ${expPct}%"></div>
              </div>
            </div>
            ` : ''}
            
            <div class="char-stats">
              <span>‚öîÔ∏è ${char.damage}</span>
              <span>üõ°Ô∏è ${char.defense}</span>
              <span>‚ö° ${char.attackSpeed}/s</span>
              ${isPlayer && char.skillPoints > 0 ? `<span>üìñ ${char.skillPoints} pts</span>` : ''}
            </div>
            
            ${skillsHtml}
          </div>
        </div>
      `;
    }
    
    function renderParties() {
      playerPartyEl.innerHTML = Object.values(playerCharacters)
        .map(char => renderCharacterCard(char, true))
        .join('');
      
      enemyPartyEl.innerHTML = Object.values(enemyCharacters)
        .map(char => renderCharacterCard(char, false))
        .join('');
      
      // Update summaries
      const aliveHeroes = Object.values(playerCharacters).filter(c => c.health > 0).length;
      const totalHeroes = Object.values(playerCharacters).length;
      document.getElementById('player-summary').textContent = `${aliveHeroes}/${totalHeroes} Alive`;
      
      const aliveEnemies = Object.values(enemyCharacters).filter(c => c.health > 0).length;
      const totalEnemies = Object.values(enemyCharacters).length;
      document.getElementById('enemy-summary').textContent = `${aliveEnemies}/${totalEnemies} Alive`;
    }
    
    function handleTrackerOutput(output) {
      // Batch UI updates - only update every 50 events
      updateCounter++;
      const shouldUpdate = updateCounter % 50 === 0;
      
      // Update character data from tracker (but less frequently)
      if (shouldUpdate) {
        updateCharacterData();
      }
      
      // Handle specific events
      if (output.eventType === 'DoAttack') {
        // Skip visual feedback for attacks to improve performance
        // Only update UI periodically
        if (shouldUpdate) {
          for (const entity of output.entities) {
            const card = document.getElementById(`char-${entity.entityId}`);
            if (card) {
              card.classList.add('attacking');
              setTimeout(() => card.classList.remove('attacking'), 200);
            }
          }
        }
      }
      
      if (output.eventType === 'Death') {
        for (const entity of output.entities) {
          if (entity.fields.current <= 0) {
            const deadEntityId = entity.entityId;
            
            // Determine if this is a player or enemy by checking the Team component
            const teamComp = game.getComponent(deadEntityId, 'Team');
            const isPlayer = teamComp && teamComp.isPlayer;
            
            // Get character name for logging
            const charComp = game.getComponent(deadEntityId, 'Character');
            const charName = charComp ? charComp.name : 'Unknown';
            
            if (isPlayer) {
              // Player hero died - penalties applied in BRL
              addLogEntry('death', `üíÄ ${charName} has been defeated! (+50s penalty)`);
              
              // Find all alive heroes
              const aliveHeroes = [];
              for (let heroId = 0; heroId <= 3; heroId++) {
                const health = game.getComponent(heroId, 'Health');
                if (health && health.current > 0) {
                  aliveHeroes.push(heroId);
                }
              }
              
              // Retarget all enemies that were attacking the dead hero
              // Query all entities with Team and Target components to find enemies
              const allTeamEntities = game.query('Team', 'Target');
              for (const enemyId of allTeamEntities) {
                const team = game.getComponent(enemyId, 'Team');
                if (team && !team.isPlayer) {
                  const target = game.getComponent(enemyId, 'Target');
                  const health = game.getComponent(enemyId, 'Health');
                  const isEnemyAlive = health && health.current > 0;
                  
                  if (target && target.entity === deadEntityId) {
                    // Retarget to a random alive hero if any exist
                    if (aliveHeroes.length > 0) {
                      const newTarget = aliveHeroes[Math.floor(Math.random() * aliveHeroes.length)];
                      game.setComponentField(enemyId, 'Target', 'entity', newTarget);
                      
                      // Schedule a new attack to prevent enemy from stopping
                      if (isEnemyAlive) {
                        game.scheduleEvent('DoAttack', 0.1, { source: enemyId });
                      }
                    } else {
                      // No heroes left, game over
                      game.setComponentField(enemyId, 'Target', 'entity', null);
                    }
                  }
                }
              }
              
              // Check if all heroes are dead for game over
              if (aliveHeroes.length === 0) {
                gameState.gameOver = true;
                showGameBanner(false);
                if (game) {
                  game.pause();
                }
              }
            } else {
              // Enemy died
              // Query all entities with Team component to find alive enemies
              const allTeamEntities = game.query('Team', 'Target');
              const aliveEnemies = [];
              
              for (const entityId of allTeamEntities) {
                const team = game.getComponent(entityId, 'Team');
                if (team && !team.isPlayer && entityId !== deadEntityId) {
                  aliveEnemies.push(entityId);
                }
              }
              
              // Remove the dead enemy first
              game.removeEntity(deadEntityId);
              
              // Spawn a new enemy to replace it (unless game is over)
              let newEnemyId = null;
              if (!gameState.gameOver && gameState.enemiesDefeated < 1000) {
                newEnemyId = spawnEnemy();
              }
              
              // Retarget any hero that was targeting this dead enemy
              // Also schedule new attack events to prevent heroes from stopping
              for (let heroId = 0; heroId <= 3; heroId++) {
                const target = game.getComponent(heroId, 'Target');
                const health = game.getComponent(heroId, 'Health');
                const isAlive = health && health.current > 0;
                
                if (target && target.entity === deadEntityId) {
                  // Retarget to the new enemy if spawned, or a random alive enemy
                  if (newEnemyId !== null) {
                    game.setComponentField(heroId, 'Target', 'entity', newEnemyId);
                  } else if (aliveEnemies.length > 0) {
                    const randomTarget = aliveEnemies[Math.floor(Math.random() * aliveEnemies.length)];
                    game.setComponentField(heroId, 'Target', 'entity', randomTarget);
                  }
                  
                  // Schedule a new attack to prevent hero from stopping
                  // This ensures the attack chain continues even if the previous attack failed
                  if (isAlive) {
                    game.scheduleEvent('DoAttack', 0.1, { source: heroId });
                  }
                }
              }
              
              // Only log every 10th kill for summary
              if (gameState.enemiesDefeated % 10 === 0) {
                const killsSinceLast = gameState.enemiesDefeated - lastLoggedKills;
                if (killsSinceLast > 0) {
                  addLogEntry('death', `‚öîÔ∏è ${killsSinceLast} enemies defeated! Total: ${gameState.enemiesDefeated}`);
                  lastLoggedKills = gameState.enemiesDefeated;
                }
              }
            }
          }
        }
      }
      
      if (output.eventType === 'LevelUp') {
        // Only log level ups, they're important milestones
        // Update character data first to get the latest level
        updateCharacterData();
        for (const entity of output.entities) {
          const char = playerCharacters[entity.entityId];
          if (char) {
            addLogEntry('levelup', `üéâ ${char.name} leveled up to Level ${char.level}!`);
          }
        }
      }
      
      if (output.eventType === 'EnemyDefeated') {
        for (const entity of output.entities) {
          if (entity.component === 'GameState') {
            gameState.enemiesDefeated = entity.fields.enemiesDefeated;
            gameState.playerDeaths = entity.fields.playerDeaths || 0;
          }
        }
      }
      
      if (output.eventType === 'PlayerDefeated') {
        for (const entity of output.entities) {
          if (entity.component === 'GameState') {
            gameState.playerDeaths = entity.fields.playerDeaths || 0;
          }
        }
      }
      
      if (output.eventType === 'GameVictory') {
        gameState.victory = true;
        gameState.gameOver = true;
        showGameBanner(true);
      }
      
      // Update UI only periodically
      if (shouldUpdate) {
        updateUI();
        renderParties();
      }
    }
    
    function handleSimulationEvent(event) {
      switch (event.type) {
        case 'started':
          gameStatusEl.textContent = 'Running';
          gameStatusEl.style.color = '#4ade80';
          break;
        case 'paused':
          gameStatusEl.textContent = 'Paused';
          gameStatusEl.style.color = '#fbbf24';
          break;
        case 'resumed':
          gameStatusEl.textContent = 'Running';
          gameStatusEl.style.color = '#4ade80';
          break;
        case 'stopped':
          gameStatusEl.textContent = 'Stopped';
          gameStatusEl.style.color = '#f87171';
          break;
        case 'completed':
          gameStatusEl.textContent = 'Complete';
          gameStatusEl.style.color = '#8b5cf6';
          
          if (!gameState.victory) {
            // Check if all players are dead
            const allPlayersDead = Object.values(playerCharacters).every(c => c.health <= 0);
            if (allPlayersDead) {
              showGameBanner(false);
            }
          }
          
          startBtn.disabled = true;
          pauseBtn.disabled = true;
          break;
        case 'step':
          gameTimeEl.textContent = event.time.toFixed(2) + 's';
          break;
      }
      
      updateButtons();
    }
    
    function showGameBanner(victory) {
      gameBanner.className = `game-banner ${victory ? 'victory' : 'defeat'}`;
      bannerText.textContent = victory ? 'üéâ Victory! Dragon Lord Vexar Defeated! üéâ' : 'üíÄ Defeat! Your party has fallen... üíÄ';
      gameBanner.style.display = 'block';
      addLogEntry('system', victory ? 'üèÜ VICTORY! All enemies defeated!' : '‚ò†Ô∏è GAME OVER! Your party was wiped out.');
      
      // Save run to leaderboard
      updateRunStatsUI(); // Final update
      saveRunToLeaderboard();
    }
    
    function updateUI() {
      currentWaveEl.textContent = gameState.wave;
      enemiesDefeatedEl.textContent = gameState.enemiesDefeated;
      playerDeathsEl.textContent = gameState.playerDeaths;
      if (game) {
        gameTimeEl.textContent = game.getTime().toFixed(2) + 's';
      }
      updateRunStatsUI();
    }
    
    function updateButtons() {
      if (!game) return;
      
      const isRunning = game.getIsRunning();
      const isPaused = game.getIsPaused();
      
      startBtn.disabled = isRunning && !isPaused;
      pauseBtn.disabled = !isRunning || isPaused;
      pauseBtn.textContent = isPaused ? '‚ñ∂Ô∏è Resume' : '‚è∏Ô∏è Pause';
      
      // Update flee button state
      fleeBtn.disabled = !isRunning || isPaused || gameState.gameOver || !runState.canFlee;
    }
    
    function addLogEntry(type, message) {
      const time = game ? game.getTime().toFixed(2) : '0.00';
      const entry = document.createElement('div');
      entry.className = `log-entry ${type}`;
      entry.innerHTML = `<span class="log-time">[${time}s]</span><span>${message}</span>`;
      logContainer.appendChild(entry);
      logContainer.scrollTop = logContainer.scrollHeight;
      
      // Limit log entries
      while (logContainer.children.length > 100) {
        logContainer.removeChild(logContainer.firstChild);
      }
    }
    
    async function resetGame() {
      if (game) {
        game.destroy();
      }
      
      // Reset UI
      gameState = { wave: 1, enemiesDefeated: 0, playerDeaths: 0, victory: false, gameOver: false };
      gameBanner.style.display = 'none';
      logContainer.innerHTML = '';
      
      // Reinitialize
      await initGame();
      
      startBtn.disabled = false;
      pauseBtn.disabled = true;
    }
    
    // Event listeners
    startBtn.addEventListener('click', () => {
      if (game) {
        if (game.getIsPaused()) {
          game.resume();
        } else {
          game.start();
        }
        addLogEntry('system', '‚öîÔ∏è Battle begins!');
      }
      updateButtons();
    });
    
    pauseBtn.addEventListener('click', () => {
      if (game) {
        if (game.getIsPaused()) {
          game.resume();
        } else {
          game.pause();
        }
      }
      updateButtons();
    });
    
    resetBtn.addEventListener('click', resetGame);
    
    fleeBtn.addEventListener('click', handleFlee);
    
    speedSlider.addEventListener('input', (e) => {
      const speed = parseFloat(e.target.value);
      speedValue.textContent = `${speed}x`;
      if (game) {
        game.setTimeScale(speed);
      }
    });
    
    // ========================================================================
    // INITIALIZATION - DATA LOADING ORDER
    // ========================================================================
    // The data loading architecture:
    //   1. Load IR (contains rules, components, trackers, initial_state)
    //   2. Extract characters from IR.initial_state (compiled from heroes.bdl)
    //   3. Extract enemies from IR.initial_state (compiled from enemies.bdl)
    //   4. loadSourceFilesFromIR() loads BRL/BCL/BDL source for dev tools (from IR.source_map)
    //   5. initBclSystem() loads choice points for BCL editor (from IR.choice_points)
    //
    // All data comes from IR - no separate JSON files needed.
    //
    // When player customizes BCL:
    //   - Current: Stored in localStorage as text, downloadable as .bcl delta
    //   - Future: Browser-based BCL compiler creates updated IR for execution
    // ========================================================================
    
    // Initialize on load
    window.addEventListener('load', async () => {
      // Load IR (this is the source of truth for rules/components/trackers/data)
      await loadDefaultIR();
      
      // Extract character and enemy data from IR.initial_state
      if (classicRpgIR) {
        extractCharacterDataFromIR(classicRpgIR);
        extractEnemyDataFromIR(classicRpgIR);
        renderCharacterSelection();
      } else {
        console.error('Failed to load IR - cannot extract game data');
        alert('Failed to load game data. Please refresh the page.');
        return;
      }
      
      // Load source files from IR for dev mode (if IR has source_map)
      loadSourceFilesFromIR();
      
      // Initialize BCL system (loads choice points from IR if available)
      await initBclSystem();
    });
    
    // Accordion toggle function
    function toggleAccordion(id) {
      const element = document.getElementById(id);
      const toggle = document.getElementById(id + '-toggle');
      if (element && toggle) {
        element.classList.toggle('expanded');
        toggle.classList.toggle('expanded');
      }
    }
    
    // ========================================================================
    // DEV MODE / INTEGRATED IDE FUNCTIONALITY
    // ========================================================================
    
    let devModeEnabled = false;
    let currentSourceFile = 'brl';
    let highlightedLine = -1;
    let lastDebugEvent = null;
    
    // Source files - will be populated from IR source_map when IR is loaded
    // For now showing placeholder since IR format doesn't yet include source_map
    let sourceFiles = {
      brl: `// =============================================================================
// CLASSIC RPG - Blink Rule Language (BRL)
// =============================================================================
// This file defines game components, rules, trackers, and functions

// -----------------------------------------------------------------------------
// COMPONENTS - Define the data structures
// -----------------------------------------------------------------------------

component Character {
    name: string
    class: string
    level: integer = 1
    experience: integer = 0
    experienceToLevel: integer = 100
}

component Health {
    current: integer = 100
    max: integer = 100
}

component Mana {
    current: integer = 50
    max: integer = 50
}

component Combat {
    damage: integer = 10
    defense: integer = 5
    attackSpeed: decimal = 1.0
    critChance: decimal = 0.1
    critMultiplier: decimal = 2.0
}

component Target {
    entity: entity_id = null
}

component Team {
    id: string = "neutral"
    isPlayer: boolean = false
}

component Enemy {
    tier: integer = 1
    isBoss: boolean = false
    expReward: integer = 25
}

// -----------------------------------------------------------------------------
// RULES - Define the game logic
// -----------------------------------------------------------------------------

rule on DoAttack {
    attacker = event.source
    
    // Check if attacker is alive and has a target
    if attacker.Health.current <= 0 {
        return  // Dead entities can't attack
    }
    
    target = attacker.Target.entity
    if target == null {
        return  // No target to attack
    }
    
    // Calculate damage
    baseDamage = attacker.Combat.damage
    defense = target.Combat.defense
    finalDamage = max(1, baseDamage - defense)
    
    // Apply critical hit
    if random() < attacker.Combat.critChance {
        finalDamage = finalDamage * attacker.Combat.critMultiplier
    }
    
    // Apply damage
    target.Health.current -= finalDamage
    
    // Check for death
    if target.Health.current <= 0 {
        emit Death { victim: target }
    }
    
    // Schedule next attack
    attackDelay = 1.0 / attacker.Combat.attackSpeed
    schedule DoAttack after attackDelay { source: attacker }
}

rule on Death {
    victim = event.victim
    
    // Award experience if victim is an enemy
    if !victim.Team.isPlayer {
        expReward = victim.Enemy.expReward
        // Award exp to all alive players (simplified)
    }
    
    // Update game state
    gameState = @gameState
    if victim.Team.isPlayer {
        gameState.GameState.playerDeaths += 1
    } else {
        gameState.GameState.enemiesDefeated += 1
    }
}

// -----------------------------------------------------------------------------
// TRACKERS - Monitor component changes
// -----------------------------------------------------------------------------

tracker Health on DoAttack
tracker Health on Death
tracker GameState on Death`,

      bcl: `// =============================================================================
// WARRIOR SKILLS - Blink Choice Language (BCL)
// =============================================================================
// This file defines AI/player strategies for warriors

// Choice function for selecting attack target
choice select_target(attacker: entity_id): entity_id {
    // Get all enemies
    enemies = query Team where Team.isPlayer == false
    
    // Filter alive enemies
    alive = filter(enemies, e => e.Health.current > 0)
    
    // If no enemies, return null
    if count(alive) == 0 {
        return null
    }
    
    // Prioritization: lowest health first (finish kills)
    sorted = sort(alive, e => e.Health.current)
    
    return first(sorted)
}

// Choice function for using skills
choice should_use_skill(hero: entity_id, skill: string): boolean {
    // Power Strike - use when target health > 50%
    if skill == "power_strike" {
        target = hero.Target.entity
        if target == null { return false }
        healthPercent = target.Health.current / target.Health.max
        return healthPercent > 0.5 && hero.Mana.current >= 20
    }
    
    return false
}`,

      bdl: `// =============================================================================
// HEROES - Blink Data Language (BDL)
// =============================================================================
// This file defines hero character data

entity @warrior {
    Character {
        name: "Sir Braveheart"
        class: "Warrior"
        level: 1
        experience: 0
        experienceToLevel: 100
    }
    Health {
        current: 120
        max: 120
    }
    Mana {
        current: 30
        max: 30
    }
    Combat {
        damage: 18
        defense: 10
        attackSpeed: 0.8
        critChance: 0.1
        critMultiplier: 1.5
    }
    Team {
        id: "player"
        isPlayer: true
    }
    HeroInfo {
        id: "warrior"
        description: "A stalwart defender with unmatched strength."
        difficulty: "Easy"
        role: "Tank / Melee DPS"
    }
}

entity @mage {
    Character {
        name: "Elara Flamecaster"
        class: "Mage"
        level: 1
        experience: 0
        experienceToLevel: 100
    }
    Health {
        current: 70
        max: 70
    }
    Mana {
        current: 100
        max: 100
    }
    Combat {
        damage: 25
        defense: 4
        attackSpeed: 0.6
        critChance: 0.1
        critMultiplier: 2.0
    }
    Team {
        id: "player"
        isPlayer: true
    }
}`
    };
    
    // ========================================================================
    // LOAD SOURCE FILES FROM IR (For Dev Mode / Integrated IDE)
    // ========================================================================
    // Source files are the original BRL/BCL/BDL source code.
    // Used by the integrated IDE for debugging and step-through execution.
    //
    // SOURCE: IR.source_map.files[] (when compiled with --source-map flag)
    //
    // Each file in source_map has:
    //   - path: Original file path (e.g., "classic-rpg.brl")
    //   - language: "brl", "bcl", or "bdl"
    //   - content: Original source code text
    //
    // CURRENT STATE:
    //   - Uses placeholder source code (hardcoded above)
    //   - Shows example BRL/BCL/BDL structure
    //
    // FUTURE STATE:
    //   - Compiler includes source with: blink-compiler compile --source-map
    //   - Actual source loaded from IR.source_map
    //   - Line highlighting tied to rule execution via source_location
    // ========================================================================
    function loadSourceFilesFromIR() {
      if (classicRpgIR && classicRpgIR.source_map && classicRpgIR.source_map.files) {
        // Parse source files from the new source_map format
        // source_map.files is an array of {path, content, language}
        const newSourceFiles = {
          brl: '// BRL source not included in IR',
          bcl: '// BCL source not included in IR',
          bdl: '// BDL source not included in IR'
        };
        
        for (const file of classicRpgIR.source_map.files) {
          // Use the language field to determine the category
          const lang = file.language || 'brl';
          if (lang === 'brl' || lang === 'bcl' || lang === 'bdl') {
            // If there are multiple files of the same language, concatenate them
            if (newSourceFiles[lang] === `// ${lang.toUpperCase()} source not included in IR`) {
              newSourceFiles[lang] = `// Source file: ${file.path}\n\n${file.content}`;
            } else {
              newSourceFiles[lang] += `\n\n// ============================================================================\n// Source file: ${file.path}\n// ============================================================================\n\n${file.content}`;
            }
          }
        }
        
        sourceFiles = newSourceFiles;
        console.info('Loaded source files from IR source_map:', classicRpgIR.source_map.files.map(f => f.path));
      } else {
        console.warn('IR does not contain source_map, using placeholder source');
        // Keep placeholder source for demonstration
      }
    }
    
    // Dev mode DOM elements
    const devModeBtn = document.getElementById('dev-mode-btn');
    const devModePanel = document.getElementById('dev-mode-panel');
    const stepBtn = document.getElementById('step-btn');
    const step10Btn = document.getElementById('step-10-btn');
    const step100Btn = document.getElementById('step-100-btn');
    const debugRuleEl = document.getElementById('debug-rule');
    const debugEventEl = document.getElementById('debug-event');
    const debugLocationEl = document.getElementById('debug-location');
    const sourceViewerEl = document.getElementById('source-viewer');
    const sourceCodeEl = document.getElementById('source-code');
    const sourceFileTabs = document.getElementById('source-file-tabs');
    
    // Toggle dev mode
    devModeBtn.addEventListener('click', () => {
      devModeEnabled = !devModeEnabled;
      devModeBtn.classList.toggle('active', devModeEnabled);
      devModePanel.classList.toggle('active', devModeEnabled);
      
      if (game) {
        game.setDevMode(devModeEnabled);
      }
      
      if (devModeEnabled) {
        devModeBtn.textContent = 'üõ†Ô∏è Dev Mode ON';
        updateSourceDisplay();
        addLogEntry('system', 'üõ†Ô∏è Dev Mode enabled - step through execution to see source highlighting');
      } else {
        devModeBtn.textContent = 'üõ†Ô∏è Dev Mode';
        addLogEntry('system', 'üõ†Ô∏è Dev Mode disabled');
      }
    });
    
    // Step buttons
    stepBtn.addEventListener('click', () => {
      if (game && game.hasEvents()) {
        game.step();
      }
    });
    
    step10Btn.addEventListener('click', () => {
      if (game) {
        for (let i = 0; i < 10 && game.hasEvents(); i++) {
          game.step();
        }
      }
    });
    
    step100Btn.addEventListener('click', () => {
      if (game) {
        for (let i = 0; i < 100 && game.hasEvents(); i++) {
          game.step();
        }
      }
    });
    
    // Source file tab switching
    sourceFileTabs.addEventListener('click', (e) => {
      if (e.target.classList.contains('source-file-tab')) {
        const file = e.target.dataset.file;
        if (file) {
          currentSourceFile = file;
          // Update active tab
          document.querySelectorAll('.source-file-tab').forEach(tab => {
            tab.classList.toggle('active', tab.dataset.file === file);
          });
          updateSourceDisplay();
        }
      }
    });
    
    // Update source display
    function updateSourceDisplay() {
      const source = sourceFiles[currentSourceFile] || '// No source available';
      const lines = source.split('\n');
      
      let html = '';
      lines.forEach((line, index) => {
        const lineNum = index + 1;
        const isHighlighted = lineNum === highlightedLine;
        const highlightClass = isHighlighted ? 'highlighted' : '';
        
        // Apply syntax highlighting
        const highlightedContent = applySyntaxHighlighting(line);
        
        html += `<div class="source-line ${highlightClass}" data-line="${lineNum}">
          <span class="line-number">${lineNum}</span>
          <span class="line-content">${highlightedContent}</span>
        </div>`;
      });
      
      sourceCodeEl.innerHTML = html;
      
      // Scroll to highlighted line if needed
      if (highlightedLine > 0) {
        const highlightedEl = sourceCodeEl.querySelector(`.source-line[data-line="${highlightedLine}"]`);
        if (highlightedEl) {
          highlightedEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }
      }
    }
    
    // Pre-compiled regex patterns for syntax highlighting (performance optimization)
    const KEYWORD_REGEX = /\b(component|rule|tracker|choice|fn|if|else|return|on|entity|schedule|emit|query|filter|sort|first|count|where)\b/g;
    const COMMENT_REGEX = /(\/\/.*)$/gm;
    const STRING_REGEX = /("([^"\\]|\\.)*")/g;
    const NUMBER_REGEX = /\b(\d+\.?\d*)\b/g;
    const ENTITY_REGEX = /@(\w+)/g;
    
    // Simple syntax highlighting
    function applySyntaxHighlighting(line) {
      // Escape HTML first
      let escaped = line
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;');
      
      // Comments
      escaped = escaped.replace(COMMENT_REGEX, '<span class="comment">$1</span>');
      
      // Keywords - using pre-compiled regex
      escaped = escaped.replace(KEYWORD_REGEX, '<span class="keyword">$1</span>');
      
      // Strings
      escaped = escaped.replace(STRING_REGEX, '<span class="string">$1</span>');
      
      // Numbers
      escaped = escaped.replace(NUMBER_REGEX, '<span class="number">$1</span>');
      
      // Entity references
      escaped = escaped.replace(ENTITY_REGEX, '<span class="entity">@$1</span>');
      
      return escaped;
    }
    
    // Handle debug events from engine
    function handleDebugEvent(event) {
      lastDebugEvent = event;
      
      if (event.type === 'rule_start' && event.rule) {
        debugRuleEl.textContent = event.rule.name || 'anonymous';
        
        // Try to find source location
        if (event.sourceLocation) {
          debugLocationEl.textContent = `${event.sourceLocation.file}:${event.sourceLocation.line}`;
          highlightedLine = event.sourceLocation.line;
        } else {
          // Simulate finding the rule in source (demo purposes)
          // Use indexOf for better performance instead of dynamic regex
          const eventName = event.rule.trigger?.event || event.rule.name;
          if (eventName && currentSourceFile === 'brl') {
            const searchPattern = `rule on ${eventName}`;
            const matchIndex = sourceFiles.brl.indexOf(searchPattern);
            if (matchIndex !== -1) {
              const linesBefore = sourceFiles.brl.substring(0, matchIndex).split('\n');
              highlightedLine = linesBefore.length;
              debugLocationEl.textContent = `classic-rpg.brl:${highlightedLine}`;
            }
          }
        }
        
        if (event.rule.trigger?.event) {
          debugEventEl.textContent = event.rule.trigger.event;
        }
        
        updateSourceDisplay();
      }
    }
    
    // ========================================================================
    // RUN TRACKING FUNCTIONS
    // ========================================================================
    
    function initializeRun() {
      runState = {
        runId: `run_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
        startTime: Date.now(),
        simulationTime: 0,
        totalTime: 0,
        retreatCount: 0,
        retreatPenalty: 0,
        deathPenalty: 0,
        lastFleeTime: -999,
        canFlee: true
      };
      updateRunStatsUI();
    }
    
    function updateRunStatsUI() {
      // Read run stats from BRL components
      const runStatsEntities = game ? game.query('RunStats') : [];
      if (runStatsEntities.length === 0) return;
      
      const runStatsEntity = runStatsEntities[0];
      const runStats = game.getComponent(runStatsEntity, 'RunStats');
      if (!runStats) return;
      
      runState.simulationTime = game.getTime();
      runState.totalTime = runStats.totalTime;
      runState.retreatCount = runStats.retreatCount;
      runState.retreatPenalty = runStats.retreatPenalty;
      runState.deathPenalty = runStats.deathPenalty;
      runState.canFlee = runStats.canFlee;
      
      totalTimeEl.textContent = runStats.totalTime.toFixed(2) + 's';
      retreatCountEl.textContent = runStats.retreatCount;
      retreatPenaltyEl.textContent = runStats.retreatPenalty.toFixed(0) + 's';
      deathPenaltyEl.textContent = runStats.deathPenalty.toFixed(0) + 's';
      totalPenaltiesEl.textContent = (runStats.retreatPenalty + runStats.deathPenalty).toFixed(0) + 's';
      
      // Update flee button state
      if (game && game.getIsRunning()) {
        fleeBtn.disabled = !runStats.canFlee || gameState.gameOver;
        
        if (!runStats.canFlee && !gameState.gameOver) {
          const timeSinceFlee = runState.simulationTime - runStats.lastFleeTime;
          const fleeCooldown = 5; // Should match BRL FleeConfig
          const remaining = Math.ceil(fleeCooldown - timeSinceFlee);
          fleeBtn.innerHTML = `üèÉ Flee Battle <span class="flee-cooldown">(${remaining}s)</span>`;
        } else {
          fleeBtn.innerHTML = 'üèÉ Flee Battle';
        }
      }
    }
    
    function handleFlee() {
      if (!game || gameState.gameOver) return;
      
      // Check if can flee from BRL RunStats
      const runStatsEntity = game.query('RunStats')[0];
      if (!runStatsEntity) return;
      
      const runStats = game.getComponent(runStatsEntity, 'RunStats');
      if (!runStats || !runStats.canFlee) {
        addLogEntry('system', '‚è≥ Flee on cooldown...');
        return;
      }
      
      // Trigger BRL flee event - game logic handled in BRL
      game.scheduleEvent('FleeFromBattle', 0, { source: runStatsEntity });
      
      addLogEntry('system', `üèÉ Initiating tactical retreat...`);
    }
    
    // ========================================================================
    // LEADERBOARD FUNCTIONS
    // ========================================================================
    
    const STORAGE_KEY = 'blink_rpg_runs';
    const MAX_STORED_RUNS = 100;
    
    function saveRunToLeaderboard() {
      if (!runState.runId) return;
      
      const selectedCharacters = partySlots.filter(hero => hero !== null);
      
      const runData = {
        runId: runState.runId,
        timestamp: runState.startTime,
        completionTime: runState.totalTime,
        simulationTime: runState.simulationTime,
        partyComposition: {
          characters: selectedCharacters.map(c => c.name),
          characterIds: selectedCharacters.map(c => c.id),
          bclFiles: loadedBCLFiles.map(f => f.name)
        },
        statistics: {
          enemiesDefeated: gameState.enemiesDefeated,
          playerDeaths: gameState.playerDeaths,
          retreats: runState.retreatCount,
          retreatPenalty: runState.retreatPenalty,
          deathPenalty: runState.deathPenalty,
          totalPenalties: runState.retreatPenalty + runState.deathPenalty
        },
        victory: gameState.victory
      };
      
      // Load existing runs
      let runs = [];
      try {
        const stored = localStorage.getItem(STORAGE_KEY);
        if (stored) {
          runs = JSON.parse(stored);
        }
      } catch (e) {
        console.error('Failed to load runs from storage:', e);
      }
      
      // Add new run
      runs.push(runData);
      
      // Sort by completion time (fastest first)
      runs.sort((a, b) => a.completionTime - b.completionTime);
      
      // Keep only top MAX_STORED_RUNS
      if (runs.length > MAX_STORED_RUNS) {
        runs = runs.slice(0, MAX_STORED_RUNS);
      }
      
      // Save back to storage
      try {
        localStorage.setItem(STORAGE_KEY, JSON.stringify(runs));
        addLogEntry('system', `üèÜ Run saved to leaderboard! Rank: #${runs.findIndex(r => r.runId === runState.runId) + 1}`);
      } catch (e) {
        console.error('Failed to save run to storage:', e);
        addLogEntry('system', '‚ö†Ô∏è Failed to save run to leaderboard (storage error)');
      }
      
      refreshLeaderboard();
    }
    
    function refreshLeaderboard() {
      const container = document.getElementById('leaderboard-table-container');
      
      let runs = [];
      try {
        const stored = localStorage.getItem(STORAGE_KEY);
        if (stored) {
          runs = JSON.parse(stored);
        }
      } catch (e) {
        console.error('Failed to load runs:', e);
      }
      
      if (runs.length === 0) {
        container.innerHTML = '<div class="leaderboard-empty">No runs recorded yet. Complete a game to see your build on the leaderboard!</div>';
        return;
      }
      
      // Build table HTML
      let html = '<table class="leaderboard-table">';
      html += '<thead><tr>';
      html += '<th>Rank</th>';
      html += '<th>Time</th>';
      html += '<th>Party</th>';
      html += '<th>Kills</th>';
      html += '<th>Deaths</th>';
      html += '<th>Retreats</th>';
      html += '<th>Penalties</th>';
      html += '<th>Date</th>';
      html += '</tr></thead><tbody>';
      
      runs.forEach((run, index) => {
        const rank = index + 1;
        const rankClass = rank === 1 ? 'gold' : rank === 2 ? 'silver' : rank === 3 ? 'bronze' : '';
        const date = new Date(run.timestamp).toLocaleDateString();
        const time = new Date(run.timestamp).toLocaleTimeString();
        
        html += '<tr>';
        html += `<td><span class="leaderboard-rank ${rankClass}">#${rank}</span></td>`;
        html += `<td><strong>${run.completionTime.toFixed(2)}s</strong></td>`;
        html += `<td>${run.partyComposition.characters.join(', ')}</td>`;
        html += `<td>${run.statistics.enemiesDefeated}</td>`;
        html += `<td>${run.statistics.playerDeaths}</td>`;
        html += `<td>${run.statistics.retreats}</td>`;
        html += `<td>+${run.statistics.totalPenalties.toFixed(0)}s</td>`;
        html += `<td>${date} ${time}</td>`;
        html += '</tr>';
      });
      
      html += '</tbody></table>';
      container.innerHTML = html;
    }
    
    function clearLeaderboard() {
      if (!confirm('Are you sure you want to clear all leaderboard data? This cannot be undone.')) {
        return;
      }
      
      try {
        localStorage.removeItem(STORAGE_KEY);
        refreshLeaderboard();
        addLogEntry('system', 'üóëÔ∏è Leaderboard cleared');
      } catch (e) {
        console.error('Failed to clear leaderboard:', e);
      }
    }
    
    function exportLeaderboard() {
      try {
        const stored = localStorage.getItem(STORAGE_KEY);
        if (!stored) {
          alert('No leaderboard data to export');
          return;
        }
        
        const blob = new Blob([stored], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `blink_rpg_leaderboard_${Date.now()}.json`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        
        addLogEntry('system', 'üíæ Leaderboard exported');
      } catch (e) {
        console.error('Failed to export leaderboard:', e);
        alert('Failed to export leaderboard');
      }
    }
  </script>
</body>
</html>
